<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="caicoder的博客">
<meta property="og:url" content="https://caicoder.github.io/page/3/index.html">
<meta property="og:site_name" content="caicoder的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="caicoder的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://caicoder.github.io/page/3/">





  <title>caicoder的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">caicoder的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/10/iOS/Thread/Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/iOS/Thread/Thread/" itemprop="url">Thread 多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-10T12:12:42+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>Thread 多线程</h1>
<h2>线程与进程</h2>
<p><strong>进程:</strong> 在系统中正在运行的一个应用程序,每个进程之间都是独立的，每个进程均运行在其专用且受保护的内存空间内。进程是CPU分配资源和调度的单位。
<strong>线程:</strong> 一个进程(程序)的所有任务都在线程中执行，每个进程至少有一个线程(主线程)。线程是CPU调度（执行任务）的最小单位，其实质就是一段代码（一个任务）。</p>
<h2>浅谈GCD</h2>
<h3>1. GCD的两个核心概念是:<code>任务</code>和<code>队列</code>.</h3>
<h4>任务与队列</h4>
<ul>
<li>任务 : 在block中执行的代码块</li>
<li>队列 : 用来存放任务的</li>
</ul>
<h4>队列 和 线程的区别:</h4>
<p>队列中存放的任务最后都要由线程来执行!
队列的原则:先进先出,后进后出</p>
<h4>队列分类：</h4>
<p>1.串行队列 2.并发队列 3.主队列 4.全局队列</p>
<ul>
<li>串行队列:任务一个接一个的执行</li>
<li>并发队列:队列中的任务并发执行</li>
<li>主队列:跟主线程相关的队列,主队列里面的内容都会在主线程中执行</li>
<li>全局队列:一个特殊的并发队列</li>
</ul>
<h4>并发队列和全局队列的区别:</h4>
<ul>
<li>并发队列有名称,可以跟踪错误.全局队列没有.</li>
<li>在ARC中两个队列不需要考虑释放内存,但是在MRC中并发队列创造出来的需要 release 操作,而全局队列只有一个不需要.</li>
<li>一般在开发过程中我们使用全局队列</li>
</ul>
<h3>2.同步和异步:</h3>
<h4>同步异步</h4>
<p>同步:只能在当前线程中执行任务,不具备开启新线程的能力
异步:可以在新的线程中执行任务,具备开启新线程的能力</p>
<p>同步执行任务:
dispatch_sync(队列,任务)
异步执行:
dispatch_async(队列,任务)</p>
<h4>队列和执行方式组合的效果:</h4>
<ol>
<li>串行队列同步执行，既在当前线程中顺序执行</li>
<li>串行队列异步执行，开辟一条新的线程，在该线程中顺序执行</li>
<li>并行队列同步执行，不开辟线程，在当前线程中顺序执行</li>
<li>并行队列异步执行，开辟多个新的线程，并且线程会重用，无序执行</li>
<li>主队列异步执行，不开辟新的线程，顺序执行</li>
<li>主队列同步执行，会造成死锁（’主线程’和’主队列’相互等待,卡住主线程）</li>
</ol>
<h2>死锁原因</h2>
<p>队列引起的循环等待</p>
<h2>同步/异步和串行/并发</h2>
<ul>
<li>dispatch_sync(serial_queue,^{//任务});</li>
<li>dispatch_async(serial_queue,^{//任务});</li>
<li>dispatch_sync(concurrent_queue,^{//任务});</li>
<li>dispatch_async(concurrent_queue,^{//任务});</li>
</ul>
<h2>同步串行</h2>
<h3>1.</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad&#123;</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(),^&#123;</span><br><span class="line">        [self doSomething];</span><br><span class="line">    &#125;);</span><br><span class="line">//死锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-143523.jpg" alt></p>
<p>在主队列上提交了 <code>viewDidLoad</code> 与 <code>GCD Block的任务</code>,无论任务中哪一个，最终都要提交到<code>主线程</code>中处理.先分派<code>viewDidLoad</code>到主线程，由于队列<code>FIFO</code>,<code>viewDidLoad</code>的调用结束又要等待<code>Block</code>的调用结束，<code>Block</code>又在等待<code>viewDidLoad</code></p>
<p><strong>只要是同步方式提交任务，无论是提交到并发队列还是串行队列，最终都是在当前线程执行</strong></p>
<h3>2.</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad&#123;</span><br><span class="line">    dispatch_sync(serialQueue,^&#123;</span><br><span class="line">        [self doSomething];</span><br><span class="line">    &#125;);</span><br><span class="line">//没问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-143708.jpg" alt></p>
<p><code>viewDidLoad</code>添加到主队列上,提交到<code>主线程</code>上执行.<code>viewDidLoad</code>执行到某个时段时候，同步提交一个任务到一个<code>串行队列</code>上面,由于是<code>同步提交</code>任务，意味着要在当前线程执行，所以<code>串行队列</code>提交的任务也是在<code>主线程</code>上面执行,<code>串行队列</code>任务在主线程上执行完之后，再继续执行<code>viewDidLoad</code>后面的任务</p>
<h2>3.</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    dispatch_sync(global_queue,^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">        dispatch_sync(global_queue,^&#123;</span><br><span class="line">            NSLog(@&quot;3&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>12345</code></p>
<h2>异步串行</h2>
<p>##1.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad&#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">        [self doSomething];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>异步并发</h2>
<p>##1.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(global_queue,^&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    [self performSelector:@selector(printLog) withObject:nil afterDelay0];</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-(void)printLog&#123;NSLog(@&quot;2&quot;);&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>13</code>,因为子线程不会主动创建<code>runloop</code>，<code>performSelector:withObject:afterDelay</code>,即使延时0s，也是要创建相应添加到<code>runloop</code>逻辑,如果没有<code>runloop</code>是不会添加到上面，所以不会触发.</p>
<h2>dispatch_barrier_async()</h2>
<p>###怎么利用GCD实现多读单写？</p>
<ul>
<li>读者读者并发</li>
<li>读者写者互斥</li>
<li>写者写者互斥</li>
</ul>
<h3>多读单写处理</h3>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-143713.jpg" alt></p>
<h3>多读单写方案</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_async(concurrent_queue,^&#123;//写操作&#125;);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//同步读取指定数据</span><br><span class="line">-(id)objectForKey:(NSString*)key&#123;</span><br><span class="line">    __block id obj;</span><br><span class="line">    dispatch_sync(concurrent_queue,^&#123;</span><br><span class="line">        obj = xxxx;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//写</span><br><span class="line">-(void)setObject:(id)obj forKey:(NSString*)key&#123;</span><br><span class="line">    //异步栅栏调用设置数据</span><br><span class="line">    dispatch_barrier_async(concurrent_queue,^&#123;</span><br><span class="line">        xxxxx;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>NSOperation</h2>
<h3>1. NSOprationQueue 与 GCD 的区别与选用</h3>
<ol>
<li>
<p>GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；</p>
</li>
<li>
<p>在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；</p>
</li>
<li>
<p>GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。</p>
</li>
</ol>
<ol start="4">
<li>GCD优点：GCD主要与block结合使用。</li>
</ol>
<p><strong>引申:</strong></p>
<p><strong>使用NSOperation和NSOperationQueue的优点：</strong></p>
<ol>
<li>可以取消操作：在运行任务前，可以在NSOperation对象调用cancel方法，标明此任务不需要执行。但是GCD队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>
<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>
<li>监控NSOperation对象的属性：可以通过KVO来监听NSOperation的属性：可以通过isCancelled属性来判断任务是否已取消；通过isFinished属性来判断任务是否已经完成。</li>
<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它</li>
</ol>
<h3>状态控制</h3>
<ul>
<li>如果只重写<code>main</code>方法,底层控制变更任务执行完成状态，以及任务退出</li>
<li>如果重写了<code>start</code>方法，自行控制状态(什么时候是<code>isExecuting</code>,<code>isFinish</code>状态等等)</li>
</ul>
<p><strong>系统怎么移除一个 <code>isFinished==YES</code> 的NSOperation的</strong>
通过<code>KVO</code></p>
<h2>锁</h2>
<h3>@synchronized</h3>
<p>一般在创建单例对象的时候使用</p>
<h3>atomic</h3>
<p>修饰属性的关键字
对被修饰对象进行原子操作(不负责使用)</p>
<h3>OSSpinLock 自旋锁</h3>
<p>循环等待访问，不释放当前资源(while循环)
用于轻量级数据访问,简单的int值 +1/-1操作</p>
<h3>NSLock</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)methodA&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    [self methodB];</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)methodB&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    //xxxx</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//会导致死锁,要使用递归锁</span><br></pre></td></tr></table></figure></p>
<h3>NSRescursiveLock 递归锁</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//递归锁的特点是可以重入</span><br><span class="line">-(void)methodA&#123;</span><br><span class="line">    [recursiveLock lock];</span><br><span class="line">    [self methodB];</span><br><span class="line">    [recursiveLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)methodB&#123;</span><br><span class="line">    [recursiveLock lock];</span><br><span class="line">    //xxxx</span><br><span class="line">    [recursiveLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>dispatch_semaphore_t 信号量</h3>
<p>阻塞是一个主动行为
唤醒是一个被动行为</p>
<h2>iOS系统为我们提供的几钟多线程技术各自的特点是怎样的</h2>
<p>iOS系统当中主要提供3种,<code>GCD</code>、<code>NSOperation&amp;NSOperationQueue</code>、<code>NSThread</code>,一般使用 <code>GCD</code>实现简单线程同步，包括子线程分派，实现多读单写情景，<code>NSOperation</code>方便任务状态控制，添加依赖移除依赖,<code>NSThread</code>多用于常用线程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/08/iOS/Block/Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/iOS/Block/Block/" itemprop="url">Block</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T12:12:42+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>Block</h1>
<h2>1.什么是Block与Block构造</h2>
<blockquote>
<p>In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.</p>
</blockquote>
<ul>
<li><code>Block</code> 是将函数及其执行上下文封装起来的<code>对象</code></li>
<li><code>Block</code>的调用即是函数的调用</li>
</ul>
<p>如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int multiplier = 6</span><br><span class="line">int(^Block)(int) = ^int(int num)&#123;</span><br><span class="line">    return num * multiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>clang</code> 重写</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//会自动生成一个与定义Block具有相同参数与返回值的构造函数</span><br><span class="line">int(*Block)(int) = ((int(*)(int))&amp;xxx_block_impl_0[Block构造函数](函数指针,block描述,multiplier[block外传入block使用的参数])</span><br></pre></td></tr></table></figure></p>
<p>一个<code>OC Block</code> <code>Clang</code> 重写之后，编程了一个对象的构造方法，传进去的是函数指针(<code>Block</code>的实现,与外部变量,Block描述)</p>
<p><code>Block结构体</code></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如上的构造函数</span><br><span class="line">struct xxx_block_impl_0&#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __xxx_block_desc_0 *Desc;    //Block描述</span><br><span class="line">    xxx_block_impl_0(void *fp,struct ....[不详细写，其实就是将上面构造函数传进去的参数传这里])&#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    //其实是C++ 里面对结构体生成的声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>Block</code>结构体里面有个方法，可以理解成<code>OC</code>里面的便利构造器，上面通过<code>Clang</code>重写了<code>Block</code>的生成，其实就是调用这个结构体里面的构造函数，将参数传进去赋值给结构体里面的变量</p>
<h2>2.截获变量</h2>
<p>数据类型:</p>
<ul>
<li>局部变量
<ul>
<li>基本数据类型</li>
<li>对象类型</li>
</ul>
</li>
<li>静态局部变量</li>
<li>全局静态变量</li>
<li>静态全局变量</li>
</ul>
<p>具体不同参考:<a href="../knowledge/staticCompare.md">staic</a></p>
<p>如何截取:</p>
<ul>
<li>对于<strong>基本数据</strong>类型的<strong>局部变量</strong>截获其值</li>
<li>对于<strong>对象</strong>类型的局部变量<strong>连同所有权修饰符</strong>一齐截获(可以解释循环引用)</li>
<li>以<strong>指针形式</strong>截获局部静态变量</li>
<li><strong>不截获</strong>全局变量，静态全局变量</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全局变量</span><br><span class="line">int global_var = 4;</span><br><span class="line">//静态全局变量</span><br><span class="line">static int static_global_var = 5;</span><br><span class="line"></span><br><span class="line">-(void)method&#123;</span><br><span class="line">    //基本数据类型的局部变量</span><br><span class="line">    int var = 1;</span><br><span class="line">    //对象类型的局部变量</span><br><span class="line">    __unsafe_unretained id unsafe_obj = nil;</span><br><span class="line">    __strong id strong_obj = nil;</span><br><span class="line">    </span><br><span class="line">    //局部静态变量</span><br><span class="line">    static int static_var = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>3.__block 修饰符</h2>
<p><strong>一般情况下</strong>，对被截获变量进行<strong>赋值</strong>操作需要添加 <code>__block</code> 修饰符(<strong>注意是赋值!!</strong>, 赋值≠使用)</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">void(^Block)(void) = ^&#123;</span><br><span class="line">    [array addObject:@123];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不需要添加 __block,因为是使用</span><br></pre></td></tr></table></figure></p>
<p>需要__block修饰符:</p>
<ul>
<li>局部变量基本数据类型</li>
<li>局部变量对象类型</li>
</ul>
<p>不需要__block修饰符:</p>
<ul>
<li>静态局部变量</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ul>
<h3>3.1__block原理</h3>
<p><code>__block</code> 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</p>
<p>__block修饰的变量成了对象</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-20-051401.jpg" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-20-051409.jpg" alt></p>
<p><strong>栈上</strong>的 __block 的  <code>__forwading</code> 指针指向自己</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-035859.jpg" alt></p>
<h4>3.2 __forwarding存在意义</h4>
<p>不论在任何内存位置,都可以顺利访问同一个__block变量.</p>
<h2>4.Block 的内存管理</h2>
<ul>
<li>_NSConcreteGlobalBlock (全局的静态 block，不会访问任何外部变量)</li>
<li>_NSConcreteStackBlock ( 保存在栈中的 block，当函数返回时会被销毁)</li>
<li>_NSConcreateMallocBlock ( 保存在堆中的 block，当引用计数为 0 时会被销毁)</li>
</ul>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-20-051428.jpg" alt></p>
<h4>_NSConcreteGlobalBlock</h4>
<p>未捕获任何变量或仅捕获的变量为以下类型的 Block 是 NSConcreteGlobalBlock。</p>
<ul>
<li>静态变量</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void (^blk) () = ^&#123;</span><br><span class="line">    printf(&quot;Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>全局定义的Block经过代码转换后</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __blk_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __blk_block_desc_0* Desc;</span><br><span class="line">  __blk_block_impl_0(void *fp, struct __blk_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteGlobalBlock; //设置在数据区的Block</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4>_NSConcreteStackBlock</h4>
<p>只要捕获了以上三种类型以外的变量的 Block 是 NSConcreteStackBlock。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">void (^blk)() = ^() &#123;</span><br><span class="line">    printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br></pre></td></tr></table></figure></p>
<p>局部定义的Block 经过代码转换后</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; //设置在栈区的Block</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>大多数时候，clang转换的源代码通常是<code>_NSConcreteStackBlock</code>对象</p>
<p><strong>可以这么理解，NSConcreteStackBlock就是引用了外部变量的block</strong></p>
<h4>NSConcreteMallocBlock</h4>
<p>系统不提供直接创建 <code>NSConcreteMallocBlock</code> 的方式，但是可以对 <code>NSConcreteStackBlock</code> 进行 copy 操作来生成 <code>NSConcreteMallocBlock</code></p>
<p>以下情况，Block 会进行 copy 操作：</p>
<ul>
<li>手动执行 copy 方法</li>
<li>将 Block 赋值给 __strong 修饰符修饰（系统默认）的 Block 或者 id 对象</li>
<li>作为方法的返回值</li>
<li>系统 API 中含有 usingBlcok 的方法</li>
</ul>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-20-051433.jpg" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-20-051439.jpg" alt></p>
<h3>Block生命周期</h3>
<p><code>NSConcreteStackBlock</code> 是由编译器自动管理，超过作用域之外就会自动释放了。而 <code>NSConcreteMallocBlock</code> 是由程序员自己管理，如果没有被强引用也会被消耗。<code>NSConcreteGlobalBlock</code> 由于存在于全局区，所以会一直伴随着应用程序。</p>
<h2>5 .__weak 实现原理的概括</h2>
<p><code>Runtime</code>维护了一个<code>weak</code>表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</p>
<p>weak 的实现原理可以概括一下三步：</p>
<ol>
<li>初始化时：runtime会调用<code>objc_initWeak</code>函数，初始化一个新的weak指针指向对象的地址。</li>
<li>添加引用时：objc_initWeak函数会调用 <code>objc_storeWeak()</code>函数， <code>objc_storeWeak()</code>的作用是更新指针指向，创建对应的弱引用表。</li>
<li>释放时，调用<code>clearDeallocating</code>函数。<code>clearDeallocating</code>函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</li>
</ol>
<h2>6. 总结</h2>
<p><code>__weak</code> 本身是可以避免循环引用的问题的，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 <code>__strong</code> 的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题。</p>
<p><code>__block</code> 本身无法避免循环引用的问题，但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题。另外一点就是 <code>__block</code> 修饰的变量在 block 内外都是唯一的，要注意这个特性可能带来的隐患。</p>
<h2>Reference</h2>
<p><a href="https://xiaozhuanlan.com/topic/2710695843" target="_blank" rel="noopener">1.深入理解 Block</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/08/iOS/Memory/Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/iOS/Memory/Memory/" itemprop="url">内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T12:12:42+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>Memory内存管理</h1>
<h2>1.内存中的5大区分别是什么？</h2>
<ul>
<li>栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。</li>
<li>堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li>全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。</li>
<li>文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放。</li>
<li>程序代码区：存放函数体的二进制代码。</li>
</ul>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085314.jpg" alt="image-20190324161722448"></p>
<h2>2.内存管理方案</h2>
<ul>
<li>系统针对不同场景下内存管理方案不同，如小对象(NSNumber等)采用 <code>TaggedPointer</code> 内存管理方案.</li>
<li>针对64位下iOS程序采用 <code>NONPOINTER_ISA</code> 方案</li>
<li>散列表(包括引用计数表，弱引用表)</li>
</ul>
<h4>2.1 NONPOINTER_ISA</h4>
<ul>
<li>第一位的 0 或 1 代表是纯地址型 isa 指针，还是 NONPOINTER_ISA 指针。</li>
<li>第二位，代表是否有关联对象</li>
<li>第三位代表是否有 C++ 代码。</li>
<li>接下来33位代表指向的内存地址</li>
<li>接下来有 弱引用 的标记</li>
<li>接下来有是否 delloc 的标记....等等</li>
</ul>
<h4>2.2 散列表</h4>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085318.jpg" alt="image-20190324165113450"></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085324.jpg" alt="image-20190324165155926"></p>
<p>SideTable是一张哈希表.使用多张 SideTable .因为可以提高查找效率.对象的引用计数值修改时候可能存在不同线程，需要锁保证数据安全，如果用同一张表会导致效率问题，需要使用<code>分离锁</code>分离操作.</p>
<h2>3.数据结构</h2>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085931.png" alt="image-20190324165929441"></p>
<h2>4. 什么是ARC</h2>
<ul>
<li>ARC 是LLVM和Runtime共同协作的结果，进行自动引用计数的管理</li>
<li>ARC中禁止手动调用retain/release/retaincount/dealloc</li>
<li>ARC中新增weak，strong属性关键字</li>
</ul>
<h2>5.引用计数管理</h2>
<h3>alloc实现</h3>
<p>经过一系列调用，最终调用了C函数calloc,此时并没有设置引用计数为1</p>
<h3>retain实现</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SideTable &amp;table = SideTables()[this];</span><br><span class="line">//在tables里面，根据当前对象指针获取对应的sidetable</span><br><span class="line"></span><br><span class="line">size_t &amp;refcntStorage = table.refcnts[this];</span><br><span class="line">//获得引用计数</span><br><span class="line"></span><br><span class="line">//添加引用计数</span><br><span class="line">refcntStorage += SIDE_TABLE_RC_ONE(4,位计算)</span><br></pre></td></tr></table></figure></p>
<h3>release 实现</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SideTable &amp;table = SideTables()[this];</span><br><span class="line">RefcountMap::iterator it = table.refcnts.find[this];</span><br><span class="line">it-&gt;second -= SIDE_TABLE_RC_ONE</span><br></pre></td></tr></table></figure></p>
<h3>retianCount</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SideTable &amp;table = SideTables()[this];</span><br><span class="line">size_t refcnt_result = 1;</span><br><span class="line">RefcountMap::iterator it = table.refcnts.find[this];</span><br><span class="line">refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;(将向右偏移操作)</span><br></pre></td></tr></table></figure></p>
<h3>dealloc实现</h3>
<p><img src="http://img.isylar.com/media/dealloc.png" alt="deallo"></p>
<h2>弱引用管理</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 = ob1; </span><br><span class="line">    //  =&gt; 编译 </span><br><span class="line">    id objc1;</span><br><span class="line">    objc_initWeak(&amp;obj1,obj);</span><br><span class="line">    //obj1弱引用对象地址，obj被修饰对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加weak变量</p>
<p><img src="http://img.isylar.com/media/15475622619941.jpg" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-090109.png" alt="image-20190324170107697"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/08/iOS/Runloop/Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/iOS/Runloop/Runloop/" itemprop="url">Runloop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T12:12:42+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>Runloop</h1>
<p>NSRunLoop是CFRunLoop的封装,提供了面向对象的API</p>
<p>Apple 官方给 <code>Runloop</code> 的定义：
Runloop 是线程的基础支撑，是循环处理事件的机制，一个具体的 Runloop 就是一个事件处理循环。</p>
<p><strong>RunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象</strong></p>
<p><strong>事件循环指,没有消息需要处理时,休眠以避免资源占用,有消息需要处理时,立刻唤醒</strong></p>
<p><strong>Runloop 的目的是使线程在没有事情可做时进入休眠状态，避免 CPU 空转。</strong></p>
<blockquote>
<p>Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p>
</blockquote>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-053637.png" alt="img"></p>
<ul>
<li>用户态: 应用程序一般都运行在用户态上</li>
<li>内核态: 系统调用，需要使用到一些操作系统以及一些底层内核指令或者API</li>
</ul>
<h2>CFRunLoop</h2>
<p><img src="http://img.isylar.com/media/15498932761656.jpg" alt></p>
<h2>CFRunLoopMode</h2>
<p><img src="http://img.isylar.com/media/15498933418655.jpg" alt></p>
<ul>
<li>source0
需要手动唤醒线程</li>
<li>source1
具备唤醒线程的能力</li>
</ul>
<h2>CFRunLoopObserver 观察者</h2>
<p>观察时间点</p>
<ul>
<li>kCFRunLoopEntry</li>
<li>kCFRunLoopBeforeTimers</li>
<li>kCFRunLoopBeforeSources</li>
<li>kCFRunLoopBeforeWaiting</li>
<li>kCFRunLoopAfterWaiting</li>
<li>kCFRunLoopExit</li>
</ul>
<h2>各个数据结构之间关系</h2>
<p><img src="http://img.isylar.com/media/15498936308142.jpg" alt>
一个Runloop中包含很多个Mode,Mode中包含Source,Timer与Observer</p>
<p>Input Source, Timer Source, Run Loop Observer 统称为 Mode Item，这里的 Mode 指的是 Run Loop Mode。一个 Run Loop 包含若干个 Mode，每个 Mode 又包含若干个 Item。Item 与 Mode 是多对多的关系，没有 Item 的 Mode 会立刻退出</p>
<h2>Runloop Modes</h2>
<p><code>Runloop Mode</code> 是<code>事件源的集合</code> + <code>Runloop</code>观察者的集合。<strong>Runloop 每次都运行在某个特定的 mode 上。</strong></p>
<p>之所以要引入 mode 的概念，是<strong>希望 Runloop 在监听过程中过滤掉不关心的事件源，只专注于某些特定的事件。</strong></p>
<p><code>Runloop</code>总是运行在某种特定的CFRunLoopModeRef下,意思是每次<code>Runloop</code>开始时候会选择一个mode，执行这个mode里面的 <code>block</code>,<code>timer</code>等事件.这可以解释滑动过程中，<code>NSTimer</code>为什么会停止,因为滑动过程中<code>Runloop</code>处于 <code>TrackingMode</code>,<code>NSTimer</code>默认添加在<code>DefaultMode</code>,所以不执行</p>
<h4>CommonMode的特殊性</h4>
<p><code>NSRunLoopCommonModes</code></p>
<ul>
<li>CommonMode不是实际存在的一种Mode</li>
<li>是同步Source/Timer/Observer到多个Mode中的一种技术方案</li>
</ul>
<p><img src="http://img.isylar.com/media/15441532587740.png" alt></p>
<p>如果某个 <code>input source</code> 所属的 mode 不是当前监听的 mode，那 <strong>其产生的所有事件都将被 hold 住，直到 runloop 运行在与其匹配的 mode 上。</strong></p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为”Common”属性。<code>DefaultMode</code> 是 App 平时所处的状态，<code>TrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 <code>DefaultMode</code> 时，Timer 会得到重复回调，但此时滑动一个TableView时，<strong>RunLoop 会将 mode 切换为</strong><code>TrackingRunLoopMode</code>，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>同时，在默认情况下<code>NSRunLoopCommonModes</code>包含<code>NSEventTrackingRunLoopMode</code>，也就是说与<code>NSRunLoopCommonModes</code>关联的事件源也与<code>NSEventTrackingRunLoopMode</code>关联。</p>
<p>而此时，如果有子线程想通过<code>performSelecorOnMainThread...</code> 或 <code>dispatch_async(dispatch_get_main_queue(),^{})</code> 在主线程上执行某 selector，默认情况下上述两种方式产生的事件是关联到<code>NSRunLoopCommonModes</code>，因此在 UI 滑动时也会响应该事件并执行指定的 selector，从而影响滑动的流畅性。</p>
<p>为了避免此问题，可以封装上述接口，使其指定的 selector 运行在 Main Runloop 的其他 mode 上，如：<code>NSDefaultRunLoopMode</code>。</p>
<h2>Runtloop运行流程</h2>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-031607.png" alt="img"></p>
<p>Run Loop 接收的事件来源 (source) 有两种。</p>
<ul>
<li>Input Source 传送来自其他应用或线程的异步事件/消息；</li>
<li>Timer Source 传送的是基于定时器的同步事件，可以定时或重复发送。</li>
</ul>
<h2>Runloop &amp; Thread</h2>
<p><code>Runloop</code>与线程是一一对应的，一个runloop对应一个核心的线程。每个 <code>thread</code> 都有自己的 <code>Runloop</code>，可以通过 <code>NSRunLoop</code>的类方法<code>currentRunLoop</code>获取<strong>当前线程</strong>的 <code>runloop</code>。</p>
<p>但只有 <code>main thread</code> 的 <code>runloop</code> <strong>默认是开启</strong>的，<strong>其他线程如果希望持续存活下去，就需要手动开启Runloop</strong>。对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被创建，不然定时器不会回调。</p>
<p><code>Runloop</code>是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。</p>
<h2>Summary</h2>
<ul>
<li>
<p>main runloop在主界面即将显示前由系统启动(主界面 controller 的 viewWillAppear:执行后启动)；</p>
</li>
<li>
<p>runloop 启动后(唤醒后)会依次处理 timer(如果有)、source event(如果有)并在此前通知 observer；</p>
</li>
<li>
<p>main runloop每分钟会被唤醒一次</p>
</li>
<li>
<p>UI事件唤醒 main runloop 直到处理完该事件，如果该事件含有异步操作，runloop 不会等待异步操作完成；</p>
</li>
<li>
<p>UIViewController的viewWillAppear:和viewDidAppear:不在同一次 runloop 中被调用；</p>
</li>
<li>
<p>timer会唤醒 runloop 但不会使 runloop 退出；</p>
</li>
<li>
<p>如果子线程的 runloop 没有绑定 timer 或 source event，其 runloop 不会启动；</p>
</li>
<li>
<p>一次 runloop 可以处理多个事件。</p>
</li>
</ul>
<h2>注意点</h2>
<h3>Timer Sources(NSTimer)</h3>
<p>Timer source 会在未来一个预定时间向线程同步分发事件。线程可以用 Timer 来通知自己做一些事情。比如用户在搜索栏输入一连串字符之后的某个时间自动搜索一次结果。正是因为有了个延时，才让用户有机会在自动搜索发生前尽可能打出想要的搜索字符串。</p>
<p><strong>Timer 并不是实时的，会有误差</strong>。如果一个 timer 不在正在运行的 run loop 监控的 mode 中，需要一直等到 run loop 运行在一个支持这个 timer 的 mode 时，timer 才会触发。**如果一个 timer 触发的时候恰巧 run loop 正忙于执行某个 handler 程序，这个 timer 的 handler 程序需要等到下次才会通过 run loop 执行。**如果 run loop 根本不在运行，timer 永远都不会触发。</p>
<p>可以配置 timer 只生成一次或重复多次事件。重复的 timer 每次会根据已经编排的触发时间自动重新编排。如果实际的触发时间太过于延迟，甚至是晚了一个或多个周期，那么也只会触发一次，而非连续多次。<strong>之后会重新编排下次触发时间</strong>。</p>
<h2>Runloop 运用场景</h2>
<p>以<code>AFNetworking2.x</code> 保活原理来说:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">AFNetworking/NSURLConnection/AFURLConnectionOperation.m</span><br><span class="line">*/ </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">/*</span><br><span class="line">AFNetworking/NSURLConnection/AFURLConnectionOperation.m</span><br><span class="line">*/    </span><br><span class="line"></span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line"></span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如代码，为线程中Runloop添加一个 <code>[NSMachPort port]</code> <code>source1</code> 事件源，让线程不退出一直保活。直到 <code>AF3.x</code>,废弃了 <code>NSURLConnection</code>。因为<code>NSURLConnection</code>中,执行回调的要在子线程,可能回调回来线程已经销毁无法做回调.<code>3.x</code>版本中，使用了 <code>NSURLSession</code>,能指定<code>queue</code>回调，所以避免了问题</p>
<h2>Reference</h2>
<p><a href="http://zxfcumtcs.github.io/2014/11/15/runloop/" target="_blank" rel="noopener">1.谜一样的 Runloop</a></p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">2.深入理解RunLoop</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/08/iOS/OCFoundation/OCFoundation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/iOS/OCFoundation/OCFoundation/" itemprop="url">OC 语言特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T12:12:42+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>OC 语言特性</h1>
<h2>OC 基础知识</h2>
<h3>1. 成员变量 实例变量 属性</h3>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-014905.png" alt="image-20190313113006579"></p>
<p>图中的<strong>Member Variable declarations</strong>翻译过来就是<strong>成员变量的声明</strong></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类： Class (description/template for an object)</span><br><span class="line">实例： Instance (manifestation of a class)</span><br><span class="line">消息： Message (sent to object to make it act)</span><br><span class="line">方法： Method (code invoked by a Message)</span><br><span class="line">实例变量： Instance Variable (object-specific storage)</span><br><span class="line">超类/子类： Superclass/Subclass (Inheritance)</span><br><span class="line">协议：  Protocol (non-class-specific methods)</span><br></pre></td></tr></table></figure></p>
<p>从给出的英文说明，可以看出：实例（Instance）是针对 类（class）而言的。实例是指类的声明；由此推理，实例变量（Instance Variable） 是指<strong>由类声明的对象</strong>。</p>
<p>严格说来，上图中的  int  count;  是一个成员变量。</p>
<p>而 <code>NSString name；</code> 是一个实例变量（NSString是一个类）。</p>
<p>至于 id data 应该属于成员变量还是实例变量呢？  因为 id 是 OC特有的类型。从本质上讲， id 等同于 （void *）。 所以 id data 应属于 实例变量。</p>
<p><strong>成员变量</strong>：通常是指向对象或是基础类型（int, float）的简单指针。可以在.h 或是 .m 文件中声明：</p>
<p><strong>实例变量</strong>：是成员变量的一种，实例是针对类而言的，是指对类的声明；由此推理，实例变量是指由类声明的对象。</p>
<p><strong>属性</strong>：GCC 到 LLVM（low level virtual machine），编译器自动为属性添加成员变量，规则：_属性名。如果需要自定义成员变量的名字，可以使用@synthesizer实现。</p>
<h3>2.分类</h3>
<h4>2.1 特点</h4>
<ul>
<li>运行时决议 --- 比如一个数组类，在编好分类文件之后，并没有把分类当中对应添加的内容附加到相应的数组类，而是在运行时通过 runtime 真实的添加到数组类中</li>
<li>可以为系统类添加分类</li>
</ul>
<h4>2.2分类都做了哪些事</h4>
<ul>
<li>声明私有方法</li>
<li>分解体积庞大的类文件</li>
<li>把 Framework 的私有方法公开</li>
</ul>
<h4>2.3 分类中都可以添加哪些内容</h4>
<ul>
<li>实例方法</li>
<li>类方法</li>
<li>协议</li>
<li>属性(不是添加实例变量，实例变量需要通过关联对象添加)</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods; //实例方法列表</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">&#125; category_t;</span><br></pre></td></tr></table></figure></p>
<h4>2.4 加载调用栈</h4>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_objc_init</span><br><span class="line">└──map_2_images</span><br><span class="line">    └──map_images_nolock</span><br><span class="line">        └──_read_images</span><br><span class="line">            └──_remethodizeClass</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>_objc_init</code> 算是整个 objc 的入口，进行了一些初始化操作，注册了镜像状态改变时的回调函数</li>
<li><code>map_2_images</code> 主要是加锁并调用 <code>map_images_nolock</code> ，加载内存镜像相关内容</li>
<li><code>map_images_nolock</code> 在这个函数中，完成所有 class 的注册、fixup等工作，还有初始化自动释放池、初始化 side table 等工作并在函数后端调用了 <code>_read_images</code></li>
<li><code>_read_images</code> 方法干了很多苦力活，比如加载类、Protocol、Category，加载分类的代码就写在 <code>_read_images</code> 函数的尾部</li>
</ul>
<p>分类被附加到类上是在map_images的时候发生的。</p>
<p>首先拿到<code>category_t</code>数组 (获得所有<code>Category</code>文件)</p>
<ol>
<li>把category的实例方法、协议以及属性添加到类上</li>
<li>把category的类方法和协议添加到类的metaclass上</li>
</ol>
<p>把所有<code>category</code>的实例方法列表拼成了一个<code>大的实例方法列表</code>，然后转交给了attachMethodLists方法(方法，扩展也类似)</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for (uint32_t m = 0;</span><br><span class="line">             (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</span><br><span class="line">             m++)</span><br><span class="line">        &#123;</span><br><span class="line">            SEL sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">            if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">                cls-&gt;setHasCustomRR();</span><br><span class="line">                scanForCustomRR = false;</span><br><span class="line">            &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">                cls-&gt;setHasCustomAWZ();</span><br><span class="line">                scanForCustomAWZ = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fill method list array</span><br><span class="line">        newLists[newCount++] = mlist;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    // Copy old methods to the method list array</span><br><span class="line">    for (i = 0; i &lt; oldCount; i++) &#123;</span><br><span class="line">        newLists[newCount++] = oldLists[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>所谓的方法覆盖，原有的方法并没有消失，只是他在方法列表中的索引后于分类中的方法。而运行时方法查找是顺着方法列表顺序查找的。所以如果要调原方法也很简单，顺着方法列表找到最后一个对应名字的方法就是原方法。</p>
<p>以分类方法为例，类中的方法数组是一个二维数组，结构如下:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//二维数组</span><br><span class="line">[[method_t,method_t],[method_t],[method_t,method_t],...];</span><br><span class="line"></span><br><span class="line">//外围中括号指的是类方法列表数组</span><br><span class="line">//内部多个中括号只分类中的Method方法合并到类中的数组</span><br><span class="line">//代理等也是这个数据结构</span><br></pre></td></tr></table></figure></p>
<h4>2.5  Category 和 +load</h4>
<ol>
<li>在类的+load方法调用的时候，我们可以调用category中声明的方法么？</li>
</ol>
<p>可以调用，因为附加category到类的工作会先于+load方法的执行(指&quot;替换&quot;原类方法)</p>
<ol start="2">
<li>这么些个+load方法，调用顺序是咋样的呢？</li>
</ol>
<p>+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。</p>
<ul>
<li>load方法的调用顺序有两条规则:父类先于子类调用，类先于分类调用。</li>
<li>那么，在多个分类的情况下呢？取决于编译器中的compile sources中的顺序。而后编译的，在&quot;同名覆盖&quot;的情况下，方法会先被找到。</li>
</ul>
<h4>2.5 总结</h4>
<p>（1）分类添加的办法可以“覆盖”原类办法，实则各个类别的办法依然存在办法列表中。也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA。<strong>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面</strong></p>
<p>（2）同名分类办法谁能生效取决于编译顺序</p>
<p>（3）名字相同的分类会引起编译报错</p>
<h3>3. 关联对象</h3>
<h4>3.1 意义</h4>
<p>顾名思义，就是把一个对象关联到另外一个对象身上。使两者能够产生联系。</p>
<p>使用场景:</p>
<ul>
<li>运行时给cagetory添加getter和setter。因为category中添加的property不会生成带下划线&quot;_&quot;的成员变量以及getter和setter的实现。所以可以通过关联对象实现getter和setter。<strong>(主要)</strong></li>
<li>有时需要在对象中存储一些额外的信息，我们通常会从对象所属的类中继承一个子类。然后给这个子类添加额外的属性，改用这个子类。然而并非所有的情况都能这么做，有时候类的实例可能是由某种机制创建的，而开发者无法另这种机制创建出自己所写的子类实例。此时可以使用“关联对象”。</li>
<li>有时只是给某个类添加一个额外的属性，完全没有必要继承出来一个子类。此时可以使用“关联对象”。</li>
<li>delegate回调的方法中使用关联对象。有时候在一些delegate回调的方法中需要处理一些回调任务。比如发起网络请求和在delegate回调的方法中做UI的更新。这样一来，发起网络请求和在回调中更新UI的代码被分散到了两个地方，不利于管理和阅读。此时可以使用“关联对象”。</li>
</ul>
<h4>3.2 重要函数</h4>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object , const void *key)</span><br><span class="line"></span><br><span class="line">void objc_setAssociatedObject(id object,const void *key,id value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObject(id object)</span><br></pre></td></tr></table></figure></p>
<h4>3.3 关联对象本质</h4>
<ul>
<li>关联对象由 <code>AssociationsManager</code> 管理并在 <code>AssiciationsHashMap</code> 存储。</li>
<li>所有对象的关联内容都在同一个全局容器中。</li>
</ul>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-095543.jpg" alt></p>
<ul>
<li>关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 <strong>OBJC_ASSOCIATION_ASSIGN</strong> 进行<strong>关联的对象</strong>，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。[注意是用Assign关联对象(@property中用assign也会导致崩溃)]</li>
</ul>
<h3>3. 扩展</h3>
<blockquote>
<p>A class extension bears some similarity to a category, <strong>but it can only be added to a class for which you have the source code</strong> at compile time (the class is compiled at the same time as the class extension). The methods declared by a class extension are implemented in the <code>@implementation</code> block for the original class so you can’t, for example, declare a class extension on a framework class, such as a Cocoa or Cocoa Touch class like <code>NSString</code>.</p>
<p>//引用自苹果</p>
<p>//重点核心意思:与分类相似，但是只能被添加到有源码的类文件中</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//implementation file (.m) </span><br><span class="line">//.m文件中实现</span><br><span class="line">@interface ClassName ()</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>一般用扩展做什么</p>
<ul>
<li>声明私有属性</li>
<li>声明私有方法</li>
<li>声明私有成员变量</li>
</ul>
<p>扩展的特点 (和分类的区别)</p>
<ul>
<li>编译时决议(内存结构规定后无法修改)</li>
<li>只以声明的形式存在，多数情况下寄生于宿主类的.m中(即需要源码)</li>
<li>不能为系统类添加扩展</li>
</ul>
<h3>4.代理</h3>
<ul>
<li>准确的说是一种软件设计模式</li>
<li>iOS当中以@protocol形式体现</li>
<li>传递方式一对一</li>
<li>一般声明为weak以规避循环引用</li>
</ul>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318144225.png" alt></p>
<p>代理方:主动</p>
<p>委托方:被动</p>
<p>代理的实现流程:</p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318144307.png" alt></p>
<h3>5.通知</h3>
<ul>
<li>是使用<strong>观察者模式</strong>来实现用于跨层传递消息的机制</li>
<li>传递方式为一对多</li>
</ul>
<p>如何实现通知机制？（没有源代码）</p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318144554.png" alt></p>
<h3>6.KVO</h3>
<p><strong>Q:什么是KVO？</strong></p>
<p><strong>A:</strong> OC 对观察者模式的又一实现； Apple 使用了 <strong>isa 混写</strong>(isa-swizzling) 来实现KVO.</p>
<ul>
<li>
<p>KVO是基于runtime机制实现的</p>
</li>
<li>
<p>当某个类的属性对象<code>第一次被观察</code>时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的<code>通知机制</code></p>
</li>
<li>
<p>每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</p>
</li>
<li>
<p>KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</p>
</li>
</ul>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318144841.png" alt></p>
<p>当调用了 <code>addObserver:forkeypath</code>方法之后，系统会动态创建 <code>NSKVONorifying_A</code>类，同时将A的isa指针指向 NSKVONorifying_A。</p>
<p>iOS中<code>KVO</code>分为自动监听和手动触发两种形式</p>
<p>手动触发:</p>
<ol>
<li>重写监听属性的set、get方法</li>
<li>重写 <code>+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</code></li>
<li>在set方法中在赋值的前后分别调用：<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code></li>
<li>实现<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法</li>
</ol>
<p>其中需要重写</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">  if([key isEqualToString:@&quot;age&quot;])&#123;</span><br><span class="line">  //取消自动发送通知</span><br><span class="line">    return NO;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>7.KVC</h3>
<p>是一种键值对设计模式，破坏面对对象的编程思想。(不重写特定方法,找不到Key情况下会崩溃)</p>
<p>主要方法</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(id)valueForKey:(NSString *)key</span><br><span class="line">-(void)setValue:(id)value forked:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<p>寻找路径</p>
<p><code>setterKey(keySet方法)</code> -&gt; <code>_key</code> -&gt; <code>_isKey</code> -&gt; <code>key</code> -&gt; <code>iskey</code></p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318150641.png" alt></p>
<h2></h2>
<p><strong>KVC setvalue:forkey与setvalue:forkeypath的区别</strong>:</p>
<p><code>forkey</code>用于简单路径,<code>forkeypath</code>用于复合路径(比如key是对象，可以直接赋值给这个对象的属性.eg:<code>setValue:@100 forKeyPath:@&quot;person.number&quot;</code>)</p>
<h3>8.属性关键字</h3>
<p>读写权限</p>
<ul>
<li>readonly</li>
<li>readwrite      √默认关键字</li>
</ul>
<p>引用计数</p>
<ul>
<li>
<p>retain / strong</p>
</li>
<li>
<p>weak / assign</p>
<p>assign:</p>
<p>修饰基本数据类型，如int, bool等</p>
<p>修饰对象类型时，不改变其引用计数</p>
<p>会产生悬垂指针：仍然指向内存地址，如果没覆盖后还调动变量就会crash</p>
<p>weak：</p>
<p>不改变修饰对象的引用计数</p>
<p>所指对象在释放之后会自动设置为nil</p>
</li>
<li>
<p>copy</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>name</th>
<th>浅拷贝</th>
<th>深拷贝</th>
</tr>
</thead>
<tbody>
<tr>
<td>新内存空间</td>
<td>不分配</td>
<td>分配</td>
</tr>
<tr>
<td>引用计数</td>
<td>影响</td>
<td>不影响</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>源对象类型</th>
<th>拷贝方式</th>
<th>目标对象类型</th>
<th>拷贝类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>mutable对象</td>
<td>copy</td>
<td>不可变</td>
<td>深拷贝</td>
</tr>
<tr>
<td>mutable对象</td>
<td>mutableCopy</td>
<td>可变</td>
<td>深拷贝</td>
</tr>
<tr>
<td>immutable对象</td>
<td>copy</td>
<td>不可变</td>
<td>浅拷贝</td>
</tr>
<tr>
<td>immutable对象</td>
<td>mutableCopy</td>
<td>可变</td>
<td>深拷贝</td>
</tr>
</tbody>
</table>
<p>原子性</p>
<ul>
<li>atomic     √默认关键字</li>
<li>nonatomic</li>
</ul>
<p>atomic<code>保证赋值获取是线程安全,是对成员属性的直接的获取安全，并不代表操作和访问安全.</code>
比如 <code>atomic</code> 修饰的是一个数组,对数组<strong>赋值获取</strong>是安全的，但是对数组<strong>进行操作</strong>(添加对象，移除对象)是不保证线程不安全的.而且采用<code>atomic</code>消耗比较大</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [[NSArray alloc]init];	//安全</span><br><span class="line">[array addobject:obj];	//也会存在不安全</span><br></pre></td></tr></table></figure></p>
<h3>9.常见问题</h3>
<h4>1.retain和strong</h4>
<p>都是强引用，除了某些情况下不一样，比如修饰block，其他的时候也是可以通用的。</p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/MRC%E3%80%81ARCBlock%E5%85%B3%E9%94%AE%E5%AD%97.png" alt></p>
<h4>2.深拷贝浅拷贝</h4>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318154344.png" alt></p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318154359.png" alt></p>
<h4>3.copy返回的都是不可变对象</h4>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//提问， 这样写有什么问题 ?</span><br><span class="line">@property(copy)NSMutableArray *array?</span><br></pre></td></tr></table></figure></p>
<p>无论复制过来的是可变还是不可变对象，都是NSArray，当调用方调用 Array 的添加对象和移除对象等操作，对于不可变 Array 就会产生程序异常</p>
<h2>Reference</h2>
<p><a href="https://juejin.im/post/5c753bc251882505d52fba5c" target="_blank" rel="noopener">1. 面试驱动技术 - Category 相关考点(Article文件夹有收藏)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/07/iOS/Autoreleasepool/Autoreleasepool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/iOS/Autoreleasepool/Autoreleasepool/" itemprop="url">Autoreleasepool</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-07T12:12:42+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>Autoreleasepool</h1>
<p><code>AutoreleasePool</code>（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。</p>
<p>在没有手加<code>Autorelease Pool</code>的情况下， <strong>Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong></p>
<h2>1.Autoreleasepool结构</h2>
<p>编译器会把<code>@autoreleasepool{}</code>改写成:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void *ctx = objc_autoreleasePoolPush();</span><br><span class="line">&#123;&#125;中代码</span><br><span class="line">objc_autoreleasePoolPop(ctx);</span><br><span class="line">					</span><br><span class="line"></span><br><span class="line">void *objc_autoreleasePoolPush(void)&#123;</span><br><span class="line">  return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt)&#123;</span><br><span class="line">  AutoreleasePoolPage:pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码可以知道Push,Pop都是操作 <code>AutoreleasePoolPage</code>的</p>
<h3>1.1  AutoreleasePoolPage 结构</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t const magic;	//用于对当前 AutoreleasePoolPage 完整性的校验</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;		//thread 保存了当前页所在的线程</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>每一个自动释放池都是由一系列的 AutoreleasePoolPage 组成的，并且每一个 AutoreleasePoolPage 的大小都是 4096 字节</strong></p>
<h4>1.1.1 双向链表</h4>
<p>自动释放池中的 <code>AutoreleasePoolPage</code> 是以<strong>双向链表</strong>的形式连接起来的：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-140349.jpg" alt></p>
<p><code>parent</code> <em>和</em> <code>child</code> 就是用来构造双向链表的指针。</p>
<h4>1.1.2 自动释放池中的栈</h4>
<p>如果我们的一个 <code>AutoreleasePoolPage</code> 被初始化在内存的 <code>0x100816000 ~ 0x100817000</code>中，它在内存中的结构如下：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-140609.jpg" alt></p>
<p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-140809.png" alt="image-20190324220807472"></p>
<h4>POOL_SENTINEL（哨兵对象）</h4>
<p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL</code> push 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        void * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">        // do whatever you want</span><br><span class="line"></span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>上面的</em> <code>atautoreleasepoolobj</code> <em>就是一个</em> <code>POOL_SENTINEL</code>。</p>
<p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-141046.jpg" alt></p>
<h2>objc_autoreleasePoolPush</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       return page-&gt;add(obj);</span><br><span class="line">   &#125; else if (page) &#123;</span><br><span class="line">       return autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>底层转化为如上代码</p>
<p><code>hotPage</code> <em>可以理解为当前正在使用的</em> <code>AutoreleasePoolPage</code>。</p>
<p>上述方法分三种情况选择不同的代码执行：</p>
<ul>
<li>
<p>有 <code>hotPage</code> 并且当前 <code>page</code> 不满</p>
<ul>
<li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li>
</ul>
</li>
<li>
<p>有 <code>hotPage</code> 并且当前 <code>page</code> 已满</p>
<ul>
<li>调用 <code>autoreleaseFullPage</code> 初始化一个新的页</li>
<li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈</li>
</ul>
</li>
<li>
<p>无 <code>hotPage</code></p>
<ul>
<li>调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code></li>
<li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li>
</ul>
</li>
</ul>
<h3>objc_autoreleasePoolPop</h3>
<p>作用如上图</p>
<p>栈中存放的指针指向加入需要release的对象或者POOL_SENTINEL（哨兵对象，用于分隔<code>Autoreleasepool</code>）。
栈中指向POOL_SENTINEL的指针就是<code>Autoreleasepool</code>的一个标记。当<code>Autoreleasepool</code>进行出栈操作，每一个比这个哨兵对象后进栈的对象都会release。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-142843.png" alt="image-20190324222842393"></p>
<h2>2. Runloop &amp; Autoreleasepool</h2>
<p>我个人认为将 <code>AutoReleasepool</code> 、 <code>ARC</code> 、 <code>Runloop</code> 3种技术联系在一起来看是一种全面的认知.</p>
<h3>2.1Runloop 与 Autoreleasepool 创建</h3>
<p>每个<code>Runloop</code>中都会创建一个 <code>AutoReleasepool</code> 并在 <code>Runloop迭代结束</code>进行释放。何为 <code>迭代结束</code>？当前<code>Runloop</code> 进入 <code>Sleep mode</code>的时候,就结束当前 <code>Runloop</code>迭代.新的一轮<code>Runloop</code>创建一个新的 <code>AutoReleasepool</code>, <code>Pool</code>里面的临时对象在结束后得到释放(不一定即时,也有可能延后,系统决定)</p>
<p><code>Runloop</code>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<h3>2.2线程与runloop</h3>
<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2>手动@autoreleasepool 与 嵌套</h2>
<p>嵌套<code>autorelesepool</code>很好解释,pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>
<p>手动<code>autoreleasepool</code>,如下文参考2例子,可以得知这个<code>for</code>循环中，每一次循环会清理掉一次内存,因为完全执行完 <code>for</code>循环才会，<code>runloop</code>才会进行休眠，如果说是按照系统的<code>autoreleasepool</code>来说，应该是休眠前才释放，但是，文中demo内存并没有显示出循环中内存暴涨，这也说明了，<strong>手动autorelesepool 不是在内存峰值时候释放</strong></p>
<h2>Reference</h2>
<p><a href="https://draveness.me/autoreleasepool" target="_blank" rel="noopener">1.自动释放池的前世今生 ---- 深入解析 autoreleasepool</a></p>
<p><a href="http://mrpeak.cn/blog/ios-runloop/" target="_blank" rel="noopener">2. 解密Runloop</a></p>
<p><a href="https://juejin.im/post/59eabe2451882578ca2dc145" target="_blank" rel="noopener">3. 在ARC环境中autoreleasepool(runloop)的研究</a></p>
<p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">4. 黑幕背后的Autorelease</a></p>
<p><a href="https://juejin.im/post/5aca2b0a6fb9a028d700e1f8" target="_blank" rel="noopener">5. iOS RunLoop详解</a></p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">6.深入了解Runloop</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/05/08/iOS/UIViewController 的生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/iOS/UIViewController 的生命周期/" itemprop="url">UIViewController 的生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-08T12:12:42+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>1. 简述下 UIViewController 的生命周期</h3>
<p>ViewController的生命周期中各方法扫行须序如下：</p>
<p>alloc init—&gt;</p>
<p>loadView—&gt; 尽管不直接调用该方法，如多手动创建自己的视图，那么应该覆盖这个方法并将它们赋值给试图控制器的 view 属性。</p>
<p>viewDidLoad—&gt; 只有在视图控制器将其视图载入到内存之后才调用该方法，这是执行任何其他初始化操作的入口。</p>
<p>viewWillAppear—&gt; 当试图将要添加到窗口中并且还不可见的时候或者上层视图移出图层后本视图变成顶级视图时调用该方法，用于执行诸如改变视图方向等的操作。实现该方法时确保调用 [super viewWillAppear:]</p>
<p>viewDidAppear—&gt; 当视图添加到窗口中以后或者上层视图移出图层后本视图变成顶级视图时调用，用于放置那些需要在视图显示后执行的代码。确保调用 [super viewDidAppear:]</p>
<p>viewWillDisappear—&gt;
viewDidDisappear—&gt;
viewWillUnload-&gt;
viewDidUnload—&gt;
dealloc-&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/01/16/Objective-C Runtime Reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/Objective-C Runtime Reference/" itemprop="url">Objective-C Runtime Reference</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-16T19:12:42+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文档描述了OS X 2.0 objective - c运行时库函数和数据结构的支持。相关实现功能在<code>objc/objc-runtime.h</code>共享库中。</p>
<blockquote>
<p>所有const char *使用UTF-8转码</p>
</blockquote>
<h1>1 Functions</h1>
<p>所有方法前带OBJC_EXPORT</p>
<h2>1.1 Working with Classes</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *class_getName(Class cls)</span><br><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line">Class class_getSuperclass(Class cls)</span><br><span class="line"><span class="comment">// 设置类的父类</span></span><br><span class="line">Class class_setSuperclass(Class cls, Class newSuper)</span><br><span class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls)</span><br><span class="line"><span class="comment">// 获取初始化class需要的内存大小</span></span><br><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line">Ivar class_getClassVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, int8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types) </span><br><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 获取strong成员</span></span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getIvarLayout(Class cls)</span><br><span class="line"><span class="comment">// 设置strong成员</span></span><br><span class="line"><span class="keyword">void</span> class_setIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout)</span><br><span class="line"><span class="comment">// 获取weak成员</span></span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getWeakIvarLayout(Class cls)</span><br><span class="line"><span class="comment">// 设置weak成员</span></span><br><span class="line"><span class="keyword">void</span> class_setWeakIvarLayout(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *layout)</span><br><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line">objc_property_t * class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector)</span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line">Method class_getClassMethod(Class aClass, SEL aSelector)</span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line">Method * class_copyMethodList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 替代方法的实现</span></span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line"><span class="comment">// 返回方法的具体实现</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name)</span><br><span class="line"><span class="comment">// 获取类中的方法的实现,该方法的返回值类型为struct</span></span><br><span class="line">IMP class_getMethodImplementation_stret(Class cls, SEL name)</span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="built_in">BOOL</span> class_respondsToSelector(Class cls, SEL sel)</span><br><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol(Class cls, Protocol *protocol)</span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *protocol)</span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *class_copyProtocolList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line"><span class="keyword">int</span> class_getVersion(Class theClass)</span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="keyword">void</span> class_setVersion(Class theClass, <span class="keyword">int</span> version)</span><br><span class="line"><span class="comment">// 获取CoreFoundation的免费桥接</span></span><br><span class="line">Class objc_getFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name) <span class="comment">// Do not call this function yourself.</span></span><br><span class="line"><span class="comment">// 设置CoreFoundation的免费桥接</span></span><br><span class="line"><span class="keyword">void</span> objc_setFutureClass(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name) <span class="comment">// Do not call this function yourself.</span></span><br></pre></td></tr></table></figure></p>
<h2>1.2 Adding Classes</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新类和元类</span></span><br><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes)</span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair(Class cls)</span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair(Class cls)</span><br><span class="line"><span class="comment">// Do not call this function yourself.</span></span><br><span class="line">Class objc_duplicateClass(Class original, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes)</span><br></pre></td></tr></table></figure></p>
<h2>1.3 Instantiating Classes</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance(Class cls, <span class="keyword">void</span> *bytes)</span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="keyword">void</span> objc_destructInstance(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure></p>
<h2>1.4 Working with Instances</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy(<span class="keyword">id</span> obj, size_t size)</span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value)</span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue)</span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="keyword">void</span> *object_getIndexedIvars(<span class="keyword">id</span> obj)</span><br><span class="line"><span class="comment">// 返回对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar(<span class="keyword">id</span> object, Ivar ivar)</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar(<span class="keyword">id</span> object, Ivar ivar, <span class="keyword">id</span> value)</span><br><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *object_getClassName(<span class="keyword">id</span> obj)</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> object)</span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line">Class object_setClass(<span class="keyword">id</span> object, Class cls)</span><br></pre></td></tr></table></figure></p>
<h2>1.5 Obtaining Class Definitions</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表</span></span><br><span class="line"><span class="keyword">int</span> objc_getClassList(Class *buffer, <span class="keyword">int</span> bufferLen)</span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line">Class *objc_copyClassList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 返回指定类的类定义</span></span><br><span class="line"><span class="keyword">id</span> objc_lookUpClass(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 返回指定类的类定义(会调用类处理程序)</span></span><br><span class="line"><span class="keyword">id</span> objc_getClass(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 返回指定类的类定义(会终止进程)</span></span><br><span class="line"><span class="keyword">id</span> objc_getRequiredClass(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="keyword">id</span> objc_getMetaClass(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br></pre></td></tr></table></figure></p>
<h2>1.6 Working with Instance Variables</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName( Ivar ivar)</span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding( Ivar ivar)</span><br><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line">ptrdiff_t ivar_getOffset( Ivar ivar)</span><br></pre></td></tr></table></figure></p>
<h2>1.7 Associative References</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"><span class="comment">// 获取关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key)</span><br><span class="line"><span class="comment">// 移除关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure></p>
<h2>1.8 Sending Messages</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息转发 -&gt; return id</span></span><br><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br><span class="line"><span class="comment">// objc_msgSend -&gt; 返回一个double值</span></span><br><span class="line"><span class="keyword">double</span> objc_msgSend_fpret(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br><span class="line"><span class="comment">// objc_msgSend -&gt; 返回一个结构体</span></span><br><span class="line"><span class="keyword">void</span> objc_msgSend_stret(<span class="keyword">void</span> * stretAddr, <span class="keyword">id</span> theReceiver, SEL theSelector, ...)</span><br><span class="line"><span class="comment">// 发送消息到父类 -&gt; return id</span></span><br><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br><span class="line"><span class="comment">// objc_msgSend -&gt; 返回一个结构体</span></span><br><span class="line"><span class="keyword">void</span> objc_msgSendSuper_stret(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure></p>
<h2>1.9 Working with Methods</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现</span></span><br><span class="line"><span class="keyword">id</span> method_invoke(<span class="keyword">id</span> receiver, Method m, ...)</span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></span><br><span class="line"><span class="keyword">void</span> method_invoke_stret(<span class="keyword">id</span> receiver, Method m, ...)</span><br><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">SEL method_getName( Method method)</span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line">IMP method_getImplementation( Method method)</span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding( Method method)</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="keyword">char</span> * method_copyReturnType( Method method)</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="keyword">char</span> * method_copyArgumentType( Method method, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line"><span class="keyword">void</span> method_getReturnType( Method method, <span class="keyword">char</span> *dst, size_t dst_len)</span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="keyword">unsigned</span> method_getNumberOfArguments( Method method)</span><br><span class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line"><span class="keyword">void</span> method_getArgumentType( Method method, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len)</span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description *method_getDescription( Method m)</span><br><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line">IMP method_setImplementation( Method method, IMP imp)</span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations( Method m1, Method m2)</span><br></pre></td></tr></table></figure></p>
<h2>1.10 Working with Libraries</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的Objective-C框架和动态库的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **objc_copyImageNames(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *class_getImageName(Class cls)</span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **objc_copyClassNamesForImage(<span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure></p>
<h2>1.11 Working with Selectors</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* sel_getName(SEL aSelector)</span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></span><br><span class="line">SEL sel_getUid(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="built_in">BOOL</span> sel_isEqual(SEL lhs, SEL rhs)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</p>
</blockquote>
<h2>1.12 Working with Protocols</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line">Protocol *objc_getProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line">Protocol **objc_copyProtocolList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line">Protocol *objc_allocateProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议</span></span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol(Protocol *proto)</span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription(Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod)</span><br><span class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol(Protocol *proto, Protocol *addition)</span><br><span class="line"><span class="comment">// 为协议添加属性</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *protocol_getName(Protocol *p)</span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual(Protocol *proto, Protocol *other)</span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod)</span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line">objc_property_t * protocol_copyPropertyList(Protocol *protocol, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br><span class="line"><span class="comment">// 获取协议采用的协议</span></span><br><span class="line">Protocol **protocol_copyProtocolList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol(Protocol *proto, Protocol *other)</span><br></pre></td></tr></table></figure></p>
<h2>1.13 Working with Properties</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="keyword">char</span> *property_copyAttributeValue(objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure></p>
<h2>1.14 Using Objective-C Language Features</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在一个foreach循环中检测到突变的编译器插入。</span></span><br><span class="line"><span class="keyword">void</span> objc_enumerationMutation(<span class="keyword">id</span> obj)</span><br><span class="line"><span class="comment">// 设置突变处理</span></span><br><span class="line"><span class="keyword">void</span> objc_setEnumerationMutationHandler(<span class="keyword">void</span> (*handler)(<span class="keyword">id</span>))</span><br><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line">IMP imp_implementationWithBlock(<span class="keyword">id</span> block)</span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="keyword">id</span> imp_getBlock( IMP anImp)</span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="built_in">BOOL</span> imp_removeBlock( IMP anImp)</span><br><span class="line"><span class="comment">// 加载弱引用指针引用的对象并返回</span></span><br><span class="line"><span class="keyword">id</span> objc_loadWeak(<span class="keyword">id</span> *location)</span><br><span class="line"><span class="comment">// 存储__weak变量的新值</span></span><br><span class="line"><span class="keyword">id</span> objc_storeWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure></p>
<h1>2 Data Types</h1>
<h2>2.1 Class-Definition Data Structures</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C类是由Class类型来表示的，实际上是一个指向objc_class结构体的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"> </span><br><span class="line"><span class="meta"># if !__OBJC2__</span></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;  <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;  <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  <span class="comment">// 协议链表</span></span><br><span class="line"><span class="meta"># endif</span></span><br><span class="line"> </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义中的方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name    OBJC2_UNAVAILABLE; <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> *method_types OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp     OBJC2_UNAVAILABLE; <span class="comment">// 方法实现</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例变量的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name  OBJC2_UNAVAILABLE; <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type  OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset  OBJC2_UNAVAILABLE; <span class="comment">// 基地址偏移字节</span></span><br><span class="line"><span class="meta"># ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space		    OBJC2_UNAVAILABLE; <span class="comment">// </span></span><br><span class="line"><span class="meta"># endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents a category.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br><span class="line"><span class="keyword">struct</span> objc_category &#123;</span><br><span class="line">    <span class="keyword">char</span> *category_name                       OBJC2_UNAVAILABLE; <span class="comment">// 分类名</span></span><br><span class="line">    <span class="keyword">char</span> *class_name                          OBJC2_UNAVAILABLE; <span class="comment">// 分类所属的类名</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods OBJC2_UNAVAILABLE; <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *class_methods    OBJC2_UNAVAILABLE; <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols      OBJC2_UNAVAILABLE; <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">Objective-C声明的属性的类型</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针，指向方法实现的首地址</span></span><br><span class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择器，是表示一个方法的selector的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个Objective-C方法</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description &#123;</span><br><span class="line">	SEL name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">	<span class="keyword">char</span> *types;            <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123; <span class="keyword">struct</span> objc_method_list *obsolete; <span class="keyword">int</span> method_count; <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存条用过的方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span> OBJC2_UNAVAILABLE; <span class="comment">// 一个整数，指定分配的缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                    OBJC2_UNAVAILABLE; <span class="comment">// 一个整数，指定实际占用的缓存bucket的总数</span></span><br><span class="line">    Method buckets[<span class="number">1</span>]                        OBJC2_UNAVAILABLE; <span class="comment">// 指向Method数据结构指针的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *next;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    Protocol *list[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">/**&lt; The name of the attribute */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">/**&lt; The value of the attribute (usually empty) */</span></span><br><span class="line">&#125; objc_property_attribute_t; <span class="comment">// 属性的特性(attribute)</span></span><br></pre></td></tr></table></figure></p>
<h2>2.2 Instance Data Types</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何oc对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个类的实例的结构体</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY; <span class="comment">// 类的isa指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个父类的结构体</span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver; <span class="comment">// 消息的实际接收者</span></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta"># if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta"># else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class super_class; <span class="comment">// 指针当前类的父类</span></span><br><span class="line"><span class="meta"># endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2>2.3 Boolean Value</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YES or NO (非0,非nil皆为真)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="built_in">BOOL</span>;</span><br></pre></td></tr></table></figure></p>
<h2>2.4 Associative References</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied. The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> </p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/08/17/NSNotification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/17/NSNotification/" itemprop="url">Notifications</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-17T18:12:42+08:00">
                2017-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSNotificationCenter发出通知的过程中会发出一个一个NSNotification对象。</p>
<h1>1 Creating Notifications</h1>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建NSNotification</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter aName : 通知名</span></span><br><span class="line"><span class="comment">/// - parameter anObject : 通知关联的对象</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - returns: NSNotification</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(name aName: <span class="type">String</span>, object anObject: <span class="type">AnyObject?</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 创建NSNotification</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter name : 通知名</span></span><br><span class="line"><span class="comment">/// - parameter object : 通知关联的对象</span></span><br><span class="line"><span class="comment">/// - parameter userInfo : 通知携带的数据</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - returns: NSNotification</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(name: <span class="type">String</span>, object: <span class="type">AnyObject?</span>, userInfo: [<span class="type">NSObject</span> : <span class="type">AnyObject</span>]?)</span><br></pre></td></tr></table></figure></p>
<h1>2 Getting Notification Information</h1>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 通知名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="comment">/// 通知关联的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> object: <span class="type">AnyObject?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="comment">/// 通知携带的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> userInfo: [<span class="type">NSObject</span> : <span class="type">AnyObject</span>]? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p> </p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/07/16/NSBlockOperation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/16/NSBlockOperation/" itemprop="url">Managing the Blocks in the Operation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-16T12:12:42+08:00">
                2017-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSBlockOperation是NSOperation的子类，以block的方式添加任务。</p>
<h1>1 Managing the Blocks in the Operation</h1>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 初始化NSBlockOperation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(block: () -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加blcok</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addExecutionBlock</span><span class="params">(block: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 需要执行的block</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> executionBlocks: [() -&gt; <span class="type">Void</span>] &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p> </p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">caicoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">caicoder</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
