<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="caicoder的博客">
<meta property="og:url" content="https://caicoder.github.io/page/2/index.html">
<meta property="og:site_name" content="caicoder的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="caicoder的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://caicoder.github.io/page/2/">





  <title>caicoder的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">caicoder的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2019/01/01/network/4次挥手过程详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/01/network/4次挥手过程详解/" itemprop="url">4次挥手过程详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-01T12:12:42+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>4次挥手过程详解</h1>
<ul>
<li>第一次挥手(FIN=1，seq=x)</li>
</ul>
<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p>
<ul>
<li>第二次挥手(ACK=1，ACKnum=x+1)</li>
</ul>
<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p>
<ul>
<li>第三次挥手(FIN=1，seq=y)</li>
</ul>
<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p>
<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p>
<ul>
<li>第四次挥手(ACK=1，ACKnum=y+1)</li>
</ul>
<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p>
<p><img src="http://img.isylar.com/media/15439929991609.png" alt></p>
<ol>
<li>第一次： 客户端向服务器发送一个带有结束标记的报文。</li>
<li>第二次：服务器收到报文后，向客户端发送一个确认序号，同时通知自己相应的应用程序：对方要求关闭连接</li>
<li>第三次： 服务器向客户端发送一个带有结束标记的报文。</li>
<li>第四次： 客户端收到报文后，向服务器发送一个确认序号。链接关闭。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/12/15/knowledge/iOSPicLoadAndRender/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/knowledge/iOSPicLoadAndRender/" itemprop="url">图片的加载与渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T12:12:42+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>iOS中图片的加载与渲染过程</h1>
<ol>
<li>要访问的图片文件通过系统调用 <code>mmap()</code> 映射到内存，通过 <code>CGImageSourceRef</code> 访问图像数据，创建<code>CGImageRef</code>。</li>
</ol>
<p>传统操作系统的I/O操作为标准I/O，即缓存I/O。在这种I/O模型下，数据先从磁盘拷贝到内核空间的缓冲区，然后从内核空间缓冲区拷贝到用户的内存空间。这种方式的优点是减少了磁盘操作，提高性能。但因为数据在传输过程中需要在用户内存空间和内核空间间进行多次数据拷贝操作，造成很大的CPU及内存开销。</p>
<p><code>mmap()</code> 将硬盘数据直接映射到虚拟内存中，应用可以直接访问虚拟内存中对应的地址来读取数据，避免了数据在内核空间和用户空间的相互拷贝，效率更高。在<strong>使用这些数据时，虚拟内存管理系统才会根据缺页加载的机制从磁盘加载对应的数据块到物理内存，在这之前不会消耗用户空间的内存。</strong> iOS中，使用 imageNamed 或者imageWithContentsOfFile 时，系统会调用 mmap() 将图片文件映射到虚拟内存，并创建 CGImageRef 用于后续访问图片数据。</p>
<ol start="2">
<li>在主线程中，将图片数据赋值给 UIImageView 。
我们知道，在保存图片时，为了节省空间，通常会将图片编码（压缩）后再进行存储。如**果读取的图片数据为压缩后的数据的话，那就需要对其进行解码成位图（Bitmap）数据。**不同加载图片的方式，在这一步的操作上会有一定的差异。</li>
</ol>
<ul>
<li>
<p><code>imageNamed:</code> 会在图片第一次渲染到屏幕上的时候进行解码，并缓存解码后的图片数据。缓存数据存储在全局缓存中，不会随着UIImag的释放而释放。</p>
</li>
<li>
<p><code>imageWithContentsOfFile:</code> 或 <code>imageWithData:</code> 同样会在图片第一次渲染到屏幕上的时候进行解码。底层会调用到 <code>CGImageSourceCreateWithData()</code> 方法，该方法可以指定是否要缓存解码后的数据，在64位机器上默认需要缓存（<code>kCGImageSourceShouldCache</code>）。与上面的方法不同，这种方式创建的缓存会随着UIImage的释放而被释放掉。</p>
</li>
</ul>
<ol start="3">
<li>
<p>手动调用 <code>CGImageSourceCreateWithData()</code> 方法可以指定是否需要缓存（<code>kCGImageSourceShouldCache</code>），之后再调用 <code>CGImageSourceCreateImageAtIndex()</code> 可以设置是否需要立即进行解码（<code>kCGImageSourceShouldCacheImmediately</code>），如果设置为不需要立刻解码，则会在<strong>将图片渲染到屏幕上时才进行解码。</strong>（设置为立即解码会阻塞主线程，造成性能问题，详见 https://www.objc.io/issues/5-ios7/iOS7-hidden-gems-and-workarounds/）</p>
</li>
<li>
<p>UIImageView 的图层树（Layer Tree）发生变化，会生成一个 <code>Implicit Transaction</code>，这个<code>transaction</code>会自动在主线程的下一个 Runloop 进行提交。（Explicit Transaction 由显式调用 begin() 和 commit() 方法触发生成。）</p>
</li>
<li>
<p>下一个Main Runloop中，Core Animation会提交这个 Implicit Transaction。如果用户内存中的位图数据没<strong>有字节对齐</strong> ，出于渲染性能考虑，**Core Animation会对数据进行拷贝，以进行字节对齐。**之后，GPU会渲染对齐后的位图数据，展示在屏幕上。</p>
</li>
</ol>
<h3>Reference</h3>
<p><a href="http://blog.corneliamu.com/archives/95" target="_blank" rel="noopener">iOS中图片的加载与渲染过程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/12/01/knowledge/staticCompare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/01/knowledge/staticCompare/" itemprop="url">static</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-01T12:12:42+08:00">
                2018-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>static全局变量与普通的全局变量的区别／static局部变量和普通局部变量的区别／static函数与普通函数的区别</h1>
<p>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于<strong>非静态全局变量</strong>的<strong>作用域是整个源程序</strong>， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而<strong>静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效</strong>， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。</p>
<h2>Reference</h2>
<p><a href="http://www.cnblogs.com/cobain/archive/2008/01/31/1060216.html" target="_blank" rel="noopener">1. staic</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/11/15/knowledge/iOSRenderProgress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/knowledge/iOSRenderProgress/" itemprop="url">iOS 界面渲染流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-15T12:12:42+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>iOS 界面渲染流程</h1>
<p><img src="http://img.isylar.com/media/15420320733034-1.jpg" alt="15420320733034"></p>
<ol>
<li>
<p>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层级关系，查询是否有重写 <code>drawRect:</code> 或 <code>drawLayer:inContext:</code>方法，<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong></p>
</li>
<li>
<p>CPU 会将处理视图和图层的层级关系打包，通过 IPC（内部处理通信）通道提交给渲染服务，渲染服务由 OpenGL ES 和 GPU 组成。</p>
</li>
<li>
<p>渲染服务首先将图层数据交给 OpenGL ES 进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</p>
</li>
<li>
<p>最后，将最终要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</p>
</li>
</ol>
<blockquote>
<p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/11/15/knowledge/listAndNode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/knowledge/listAndNode/" itemprop="url">单链表结构与顺序储存结构优缺点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-15T12:12:42+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>单链表结构与顺序储存结构优缺点</h1>
<p><img src="http://img.isylar.com/media/List-Node.png" alt="List-Node"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/10/22/knowledge/static_inline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/knowledge/static_inline/" itemprop="url">内联函数,与宏的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T12:12:42+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>内联函数,与宏的区别</h1>
<p><strong>内联函数 是为了解决函数调用效率的问题</strong></p>
<p>由于函数之间的调用,会从一个内存地址调用到另外一个内存地址,当函数调用完毕之后还会返回原来函数执行的地址,函数调用会有一定的时间开销,引入内联函数是为了解决这一问题</p>
<p>没有使用 内联函数 static inLine:</p>
<p><img src="http://img.isylar.com/media/15440048099753.png" alt></p>
<p>使用内联函数 static inLine:</p>
<p><img src="http://img.isylar.com/media/15440048170044.png" alt></p>
<h4>结论:</h4>
<p>使用 inline 修饰的函数,在编译的时候,会把代码<strong>直接嵌入调用代码中</strong>.就相当于用 #define 宏定义来定义一个 add 函数那样 与 #define 的区别是:</p>
<ul>
<li>
<p>#define 定义的格式要有要求,而使用 inline 则就就像平常写函数那样,只要加上 inline 即可</p>
</li>
<li>
<p>使用 #define 宏定义的代码 ,编译器不会对其进行参数有效性检查,仅仅只是对符号表进行替换.</p>
</li>
<li>
<p>#define 宏定义的代码,其返回值不能被强制转换的适合的转换类型.</p>
</li>
<li>
<p>在 inline 加上 &quot;static&quot; 修饰符,只是为了声明该函数只在该文件中可见! 也就是说,在同一个工程中,就算在其他文件中出现同名,同参数也不会引起函数重复定义的错误</p>
</li>
</ul>
<h5>inline 与 宏的区别</h5>
<h5>优点相比于函数:</h5>
<ol>
<li>inline函数避免了普通函数的,在汇编时必须调用call的缺点:取消了函数的参数压栈，减少了调用的开销,提高效率.所以执行速度确比一般函数的执行速度要快.</li>
</ol>
<p>2)集成了宏的优点,使用时直接用代码替换(像宏一样);</p>
<h5>优点相比于宏:</h5>
<p>1)避免了宏的缺点:需要预编译.因为inline内联函数也是函数,不需要预编译.</p>
<p>2)编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。</p>
<p>3)可以使用所在类的保护成员及私有成员。</p>
<h5>inline内联函数的注意事项</h5>
<p>1.内联函数只是我们向编译器提供的申请,<strong>编译器不一定采取inline形式调用函数.</strong></p>
<p>2.内联函数不能承载大量的代码.<strong>如果内联函数的函数体过大,编译器会自动放弃内联.</strong></p>
<p>3.内联函数内不允许使用循环语句或开关语句.</p>
<p>4.内联函数的定义须在调用之前.</p>
<h3>Reference</h3>
<ol>
<li><a href="https://www.jianshu.com/p/365a2395171d" target="_blank" rel="noopener">ios 内联函数,与宏的区别以及注意事项</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/10/18/knowledge/iOSRenderFramework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/18/knowledge/iOSRenderFramework/" itemprop="url">iOS 渲染框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-18T12:12:42+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>iOS 渲染框架</h1>
<h1><code>UIKit</code></h1>
<p><code>UIKit</code>自身并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（<code>UIView</code>继承自<code>UIResponder</code>），事件响应的传递大体是经过逐层的视图树遍历实现的。</p>
<h1><code>Core Animation</code></h1>
<p><code>Core Animation</code>是一个复合引擎，其职责是尽可能快地<strong>组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即CALayer）</strong>，这些图层会被存储在一个叫做图层树的体系之中。</p>
<h1><code>Core Graphics</code></h1>
<p><code>Core Graphics</code>基于<code>Quartz</code>高级绘图引擎，主要用于<strong>运行时绘制图像</strong>。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及PDF文档创建，</p>
<p>开发者需要在<strong>运行时创建图像</strong>时，可以使用<code>Core Graphics</code>去绘制。</p>
<h1><code>Core Image</code></h1>
<p><code>Core Image</code>与<code>Core Graphics</code>恰恰相反，<code>Core Graphics</code>用于在<strong>运行时创建图像</strong>，而<code>Core Image</code>用于<strong>处理运行前创建的图像</strong>。</p>
<h1><code>OpenglES</code></h1>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/09/15/Interview/【2018 年最新】 iOS 面试题及答案 (一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/15/Interview/【2018 年最新】 iOS 面试题及答案 (一)/" itemprop="url">面试题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-15T12:12:42+08:00">
                2018-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文地址 https://juejin.im/post/5a7c011d5188257a654cc76d</p>
</blockquote>
<h5>1、设计模式是什么？ 你知道哪些设计模式，并简要叙述？</h5>
<p>设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。 1). MVC 模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。 2). MVVM 模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。 3). 单例模式：通过 static 关键词，声明全局变量。在整个进程运行期间只会被赋值一次。 4). 观察者模式：KVO 是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。 5). 委托模式：代理 + 协议的组合。实现 1 对 1 的反向传值操作。 6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。</p>
<h5>2、MVC 和 MVVM 的区别？</h5>
<p>1). MVVM 是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到 VM 中去处理。 2). MVC 是一切设计的基础，所有新的设计模式都是基于 MVC 进行的改进。</p>
<h5>3、#import 跟 #include 有什么区别，@class 呢，#import&lt;&gt; 跟 #import“” 有什么区别？</h5>
<p>答： 1). #import 是 Objective-C 导入头文件的关键字，#include 是 C/C++ 导入头文件的关键字，使用 #import 头文件会自动只导入一次，不会重复导入。 2). @class 告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。 3). #import&lt;&gt; 用来包含系统的头文件，#import”” 用来包含用户头文件。</p>
<h5>4、frame 和 bounds 有什么不同？</h5>
<p>frame 指的是：该 view 在父 view 坐标系统中的位置和大小。(参照点是父 view 的坐标系统) bounds 指的是：该 view 在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</p>
<h5>5、Objective-C 的类可以多重继承么？可以实现多个接口么？Category 是什么？重写一个类的方式用继承好还是分类好？为什么？</h5>
<p>答：Objective-C 的类不可以多重继承；可以实现多个接口（协议）；Category 是类别；一般情况用分类好，用 Category 去重写类的方法，仅对本 Category 有效，不会影响到其他类与原有类的关系。</p>
<h5>6、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</h5>
<p>@property 的本质是什么？ @property = ivar + getter + setter; “属性” (property) 有两大概念：ivar（实例变量）、getter+setter（存取方法）</p>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过 “存取方法”(access method) 来访问。其中，“获取方法” (getter)用于读取变量值，而 “设置方法” (setter) 用于写入变量值。</p>
<h5>7、@property 中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h5>
<p>属性可以拥有的特质分为四类: 1. 原子性 --- nonatomic 特质 2. 读 / 写权限 ---readwrite(读写)、readonly (只读) 3. 内存管理语义 ---assign、strong、 weak、unsafe_unretained、copy 4. 方法名 ---getter= 、setter= 5. 不常用的：nonnull,null_resettable,nullable</p>
<h5>8、属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</h5>
<p>答： 1). readwrite 是可读可写特性。需要生成 getter 方法和 setter 方法。 2). readonly 是只读特性。只会生成 getter 方法，不会生成 setter 方法，不希望属性在类外改变。 3). assign 是赋值特性。setter 方法将传入参数赋值给实例变量; 仅设置变量时, assign 用于基本数据类型。 4). retain(MRC)/strong(ARC) 表示持有特性。setter 方法将传入参数先保留，再赋值，传入参数的 retaincount 会 + 1。 5). copy 表示拷贝特性。setter 方法将传入对象复制一份，需要完全一份新的变量时。 6). nonatomic 非原子操作。决定编译器生成的 setter 和 getter 方法是否是原子操作，atomic 表示多线程安全，一般使用 nonatomic，效率高。</p>
<h5>9、什么情况使用 weak 关键字，相比 assign 有什么不同？</h5>
<p>1. 在 ARC 中, 在有可能出现循环引用的时候, 往往要通过让其中一端使用 weak 来解决, 比如: delegate 代理属性。 2. 自身已经对它进行一次强引用, 没有必要再强引用一次, 此时也会使用 weak, 自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用 strong。</p>
<p>IBOutlet 连出来的视图属性为什么可以被设置成 weak? 因为父控件的 subViews 数组已经对它有一个强引用。</p>
<p>不同点： assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。 weak 表明该属性定义了一种 “非拥有关系”。在属性所指的对象销毁时，属性值会自动清空 (nil)。</p>
<h5>10、怎么用 copy 关键字？</h5>
<p>用途：</p>
<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block 也经常使用 copy 关键字。</li>
</ol>
<p>说明： block 使用 copy 是从 MRC 遗留下来的 “传统”, 在 MRC 中, 方法内部的 block 是在栈区的, 使用 copy 可以把它放到堆区. 在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道 “编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>
<h5>11、用 @property 声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</h5>
<p>答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<ol>
<li>因为父类指针可以指向子类对象, 使用 copy 的目的是为了让本对象的属性不受外界影响, 使用 copy 无论给我传入是一个可变对象还是不可对象, 我本身持有的就是一个不可变的副本。</li>
<li>如果我们使用是 strong , 那么这个属性就有可能指向一个可变对象, 如果这个可变对象在外部被修改了, 那么会影响该属性。</li>
</ol>
<p>// 总结：使用 copy 的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</p>
<h5>12、浅拷贝和深拷贝的区别？</h5>
<p>答： 浅拷贝：只复制指向对象的指针，而不复制引用对象本身。 深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改 A 时，A_copy 不变。</p>
<h5>13、系统对象的 copy 与 mutableCopy 方法？</h5>
<p>不管是集合类对象（NSArray、NSDictionary、NSSet ... 之类的对象），还是非集合类对象（NSString, NSNumber ... 之类的对象），接收到 copy 和 mutableCopy 消息时，都遵循以下准则：</p>
<ol>
<li>copy 返回的是不可变对象（immutableObject）；如果用 copy 返回值调用 mutable 对象的方法就会 crash。</li>
<li>mutableCopy 返回的是可变对象（mutableObject）。</li>
</ol>
<p>一、非集合类对象的 copy 与 mutableCopy 在非集合类对象中，对不可变对象进行 copy 操作，是指针复制，mutableCopy 操作是内容复制； 对可变对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下： NSString *str = @&quot;hello word!&quot;; NSString *strCopy = [str copy] // 指针复制，strCopy 与 str 的地址一样 NSMutableString *strMCopy = [str mutableCopy] // 内容复制，strMCopy 与 str 的地址不一样</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *mutableStr = [NSMutableString stringWithString: @&quot;hello word!&quot;];</span><br><span class="line">NSString *strCopy = [mutableStr copy] // 内容复制</span><br><span class="line">NSMutableString *strMCopy = [mutableStr mutableCopy] // 内容复制</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<p>二、集合类对象的 copy 与 mutableCopy (同上) 在集合类对象中，对不可变对象进行 copy 操作，是指针复制，mutableCopy 操作是内容复制； 对可变对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制) NSArray *arr = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]; NSArray *copyArr = [arr copy]; // 指针复制 NSMutableArray *mCopyArr = [arr mutableCopy]; // 单层内容复制</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];</span><br><span class="line">NSArray *copyArr = [mutableArr copy]; // 单层内容复制</span><br><span class="line">NSMutableArray *mCopyArr = [mutableArr mutableCopy]; // 单层内容复制</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<p>【总结一句话】： 只有对不可变对象进行 copy 操作是指针复制（浅复制），其它情况都是内容复制（深复制）！</p>
<h5>14、这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;？</h5>
<p>问题：添加, 删除, 修改数组内的元素的时候, 程序会因为找不到对应的方法而崩溃。 // 如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460 // copy 后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法） 原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加 / 修改。</p>
<h5>15、如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h5>
<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 具体步骤： 1. 需声明该类遵从 NSCopying 协议 2. 实现 NSCopying 协议的方法。 // 该协议只有一个方法: - (id)copyWithZone:(NSZone *)zone; // 注意：使用 copy 修饰符，调用的是 copy 方法，其实真正需要实现的是 “copyWithZone” 方法。</p>
<h5>16、写一个 setter 方法用于完成 @property (nonatomic, retain) NSString *name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name ？</h5>
<p>答： // retain</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)str &#123;</span><br><span class="line">  [str retain];</span><br><span class="line">  [_name release];</span><br><span class="line">  _name = str;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<p>// copy</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)str &#123;</span><br><span class="line">  id t = [str copy];</span><br><span class="line">  [_name release];</span><br><span class="line">  _name = t;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>17、@synthesize 和 @dynamic 分别有什么作用？</h5>
<p>@property 有两个对应的词，一个是 @synthesize（合成实例变量），一个是 @dynamic。 如果 @synthesize 和 @dynamic 都没有写，那么默认的就是 @synthesize var = _var; // 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</p>
<ol>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器，属性的 setter 与 getter 方法由用户自己实现，不自动生成（如，@dynamic var）。</li>
</ol>
<h5>18、常见的 Objective-C 的数据类型有那些，和 C 的基本数据类型有什么区别？如：NSInteger 和 int</h5>
<p>答： Objective-C 的数据类型有 NSString，NSNumber，NSArray，NSMutableArray，NSData 等等，这些都是 class，创建后便是对象，而 C 语言的基本数据类型 int，只是一定字节的内存空间，用于存放数值; NSInteger 是基本数据类型，并不是 NSNumber 的子类，当然也不是 NSObject 的子类。NSInteger 是基本数据类型 Int 或者 Long 的别名 (NSInteger 的定义 typedef long NSInteger)，它的区别在于，NSInteger 会根据系统是 32 位还是 64 位来决定是本身是 int 还是 long。</p>
<h5>19、id 声明的对象有什么特性？</h5>
<p>答：id 声明的对象具有运行时的特性，即可以指向任意类型的 Objcetive-C 的对象。</p>
<h5>20、Objective-C 如何对内存管理的，说说你的看法和解决方法？</h5>
<p>答：Objective-C 的内存管理主要有三种方式 ARC(自动内存计数)、手动内存计数、内存池。 1). 自动内存计数 ARC：由 Xcode 自动在 App 编译阶段，在代码中添加内存管理代码。 2). 手动内存计数 MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。 3). 内存释放池 Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后 (drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受 runloop 机制影响。</p>
<h5>21、Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</h5>
<p>答：线程创建有三种方法：使用 NSThread 创建、使用 GCD 的 dispatch、使用子类化的 NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行代码，方法是 performSelectorOnMainThread，如果想延时执行代码可以用 performSelector:onThread:withObject:waitUntilDone:</p>
<h5>22、Category（类别）、 Extension（扩展）和继承的区别</h5>
<p>区别：</p>
<ol>
<li>分类有名字，类扩展没有分类名字，是一种特殊的分类。</li>
<li>分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。</li>
<li>继承可以增加，修改或者删除方法，并且可以增加属性。</li>
</ol>
<h5>23、我们说的 OC 是动态运行时语言是什么意思？</h5>
<p>答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别, 以及调用该类别对象指定方法。</p>
<h5>24、为什么我们常见的 delegate 属性都用是 week 而不是 retain/strong？</h5>
<p>答：是为了防止 delegate 两端产生不必要的循环引用。 @property (nonatomic, weak) id delegate;</p>
<h5>25、什么时候用 delete，什么时候用 Notification？</h5>
<p>Delegate(委托模式)：1 对 1 的反向消息通知功能。 Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</p>
<h5>26、什么是 KVO 和 KVC？</h5>
<p>1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值） 举例说明： stu.name = @&quot;张三&quot; // 点语法给属性赋值 [stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;]; // 通过字符串使用 KVC 方式给属性赋值 stu1.nameLabel.text = @&quot;张三&quot;; [stu1 setValue:@&quot;张三&quot; forKey:@&quot;nameLabel.text&quot;]; // 跨层赋值 2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。 KVO 只能被 KVC 触发，包括使用 setValue:forKey: 方法和点语法。 // 通过下方方法为属性添加 KVO 观察</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   - (void)addObserver:(NSObject *)observer</span><br><span class="line">                     forKeyPath:(NSString *)keyPath</span><br><span class="line">                     options:(NSKeyValueObservingOptions)options</span><br><span class="line">                     context:(nullable void *)context;</span><br><span class="line">   // 当被观察的属性发送变化时，会自动触发下方方法                   </span><br><span class="line">   - (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                              ofObject:(id)object</span><br><span class="line">                                  change:(NSDictionary *)change</span><br><span class="line">                                 context:(void *)context&#123;&#125;;</span><br><span class="line"></span><br><span class="line">KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>27、KVC 的底层实现？</h5>
<p>当一个对象调用 setValue 方法时，方法内部会做以下操作： 1). 检查是否存在相应的 key 的 set 方法，如果存在，就调用 set 方法。 2). 如果 set 方法不存在，就会查找与 key 相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。 3). 如果没有找到_key，就会查找相同名称的属性 key，如果有就直接赋值。 4). 如果还没有找到，则调用 valueForUndefinedKey: 和 setValue:forUndefinedKey: 方法。 这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>
<h5>28、KVO 的底层实现？</h5>
<p>KVO 基于 runtime 机制实现。</p>
<h5>29、ViewController 生命周期</h5>
<p>按照执行顺序排列：</p>
<ol>
<li>initWithCoder：通过 nib 文件初始化时触发。</li>
<li>awakeFromNib：nib 文件被加载的时候，会发生一个 awakeFromNib 的消息到 nib 文件中的每个对象。</li>
<li>loadView：开始加载视图控制器自带的 view。</li>
<li>viewDidLoad：视图控制器的 view 被加载完成。</li>
<li>viewWillAppear：视图控制器的 view 将要显示在 window 上。</li>
<li>updateViewConstraints：视图控制器的 view 开始更新 AutoLayout 约束。</li>
<li>viewWillLayoutSubviews：视图控制器的 view 将要更新内容视图的位置。</li>
<li>viewDidLayoutSubviews：视图控制器的 view 已经更新视图的位置。</li>
<li>viewDidAppear：视图控制器的 view 已经展示到 window 上。</li>
<li>viewWillDisappear：视图控制器的 view 将要从 window 上消失。</li>
<li>viewDidDisappear：视图控制器的 view 已经从 window 上消失。</li>
</ol>
<h5>30、方法和选择器有何不同？</h5>
<p>selector 是一个方法的名字，方法是一个组合体，包含了名字和实现。</p>
<h5>31、你是否接触过 OC 中的反射机制？简单聊一下概念和使用</h5>
<p>1). class 反射 通过类名的字符串形式实例化对象。 Class class = NSClassFromString(@&quot;student&quot;); Student *stu = [[class alloc] init]; 将类名变为字符串。 Class class =[Student class]; NSString <em>className = NSStringFromClass(class); 2). SEL 的反射 通过方法的字符串形式实例化方法。 SEL selector = NSSelectorFromString(@&quot;setName&quot;);
[stu performSelector:selector withObject:@&quot;Mike&quot;]; 将方法变成字符串。 NSStringFromSelector(@selector</em>(setName:));</p>
<h5>32、调用方法有两种方式：</h5>
<p>1). 直接通过方法名来调用。[person show]; 2). 间接的通过 SEL 数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];</p>
<h5>33、如何对 iOS 设备进行性能测试？</h5>
<p>答： Profile-&gt; Instruments -&gt;Time Profiler</p>
<h5>34、开发项目时你是怎么检查内存泄露？</h5>
<p>1). 静态分析 analyze。 2). instruments 工具里面有个 leak 可以动态分析。</p>
<h5>35、什么是懒加载？</h5>
<p>答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。 我觉得最好也最简单的一个例子就是 tableView 中图片的加载显示了, 一个延时加载, 避免内存过高, 一个异步加载, 避免线程堵塞提高用户体验。</p>
<h5>36、类变量的 @public，@protected，@private，@package 声明各有什么含义？</h5>
<p>@public 任何地方都能访问; @protected 该类和子类中访问, 是默认的; @private 只能在本类中访问; @package 本包内使用, 跨包不可以。</p>
<h5>37、什么是谓词？</h5>
<p>谓词就是通过 NSPredicate 给定的逻辑条件作为约束条件, 完成对数据的筛选。 // 定义谓词对象, 谓词对象中包含了过滤条件 (过滤条件比较多) NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&lt;%d&quot;,30]; // 使用谓词条件过滤数组中的元素, 过滤之后返回查询的结果 NSArray *array = [persons filteredArrayUsingPredicate:predicate];</p>
<h5>38、isa 指针问题</h5>
<p>isa：是一个 Class 类型的指针. 每个实例对象有个 isa 的指针, 他指向对象的类, 而 Class 里也有个 isa 的指针, 指向 meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时, 先会从本身查找类方法的实现, 如果没有, 元类会向他父类查找该方法。同时注意的是: 元类 (meteClass) 也是类, 它也是对象。元类也有 isa 指针, 它的 isa 指针最终指向的是一个根元类(root meteClass)。根元类的 isa 指针指向本身, 这样形成了一个封闭的内循环。</p>
<h5>39、如何访问并修改一个类的私有属性？</h5>
<p>1). 一种是通过 KVC 获取。 2). 通过 runtime 访问并修改私有属性。</p>
<h5>40、一个 objc 对象的 isa 的指针指向什么？有什么作用？</h5>
<p>答：指向他的类对象, 从而可以找到对象上的方法。</p>
<h5>41、下面的代码输出什么？</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init &#123;</span><br><span class="line">   if (self = [super init]) &#123;</span><br><span class="line">       NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son</span><br><span class="line">       NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son</span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<p>// 解析： self 是类的隐藏参数，指向当前调用方法的这个类的实例。 super 是一个 Magic Keyword，它本质是一个编译器标示符，和 self 是指向的同一个消息接收者。 不同的是：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。 上面的例子不管调用 [self class] 还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。</p>
<h5>42、写一个完整的代理，包括声明、实现</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建</span><br><span class="line">@protocol MyDelagate</span><br><span class="line">@required</span><br><span class="line">-(void)eat:(NSString *)foodName; </span><br><span class="line">@optional</span><br><span class="line">-(void)run;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  声明 .h</span><br><span class="line">@interface person: NSObject&lt;MyDelagate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  实现 .m</span><br><span class="line">@implementation person</span><br><span class="line">- (void)eat:(NSString *)foodName &#123; </span><br><span class="line">   NSLog(@&quot;吃:%@!&quot;, foodName);</span><br><span class="line">&#125; </span><br><span class="line">- (void)run &#123;</span><br><span class="line">   NSLog(@&quot;run!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>43、isKindOfClass、isMemberOfClass、selector 作用分别是什么</h5>
<p>isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。 isMemberOfClass：某个对象确切属于某个类型。 selector：通过方法名，获取在内存中的函数的入口地址。</p>
<h5>44、delegate 和 notification 的区别</h5>
<p>1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。 2). notification 通过维护一个 array，实现一对多消息的转发。 3). delegate 需要两者之间必须建立联系，不然没法调用代理的方法；notification 不需要两者之间有联系。</p>
<h5>45、什么是 block？</h5>
<p>闭包（block）：闭包就是获取其它函数局部变量的匿名函数。</p>
<h5>46、block 反向传值</h5>
<p>在控制器间传值可以使用代理或者 block，使用 block 相对来说简洁。</p>
<p>在前一个控制器的 touchesBegan: 方法内实现如下代码。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  // OneViewController.m</span><br><span class="line">  TwoViewController *twoVC = [[TwoViewController alloc] init];</span><br><span class="line">  twoVC.valueBlcok = ^(NSString *str) &#123;</span><br><span class="line">  	NSLog(@&quot;OneViewController拿到值：%@&quot;, str); </span><br><span class="line">  &#125;;</span><br><span class="line">  [self presentViewController:twoVC animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">  // TwoViewController.h   （在.h文件中声明一个block属性）</span><br><span class="line">  @property (nonatomic ,strong) void(^valueBlcok)(NSString *str);</span><br><span class="line"></span><br><span class="line">  // TwoViewController.m   （在.m文件中实现方法）</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">	// 传值:调用block</span><br><span class="line">	if (_valueBlcok) &#123;</span><br><span class="line">		_valueBlcok(@&quot;123456&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>47、block 的注意点</h5>
<p>1). 在 block 内部使用外部指针且会造成循环引用情况下，需要用__week 修饰外部指针： __weak typeof(self) weakSelf = self; 2). 在 block 内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在 block 内部再将弱指针重新强引用一下。 __strong typeof(self) strongSelf = weakSelf; 3). 如果需要在 block 内部改变外部栈区变量的话，需要在用__block 修饰外部变量。</p>
<h5>48、BAD_ACCESS 在什么情况下出现？</h5>
<p>答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</p>
<h5>49、lldb（gdb）常用的控制台调试命令？</h5>
<p>1). p 输出基本类型。是打印命令，需要指定类型。是 print 的简写 p (int)[[[self view] subviews] count] 2). po 打印对象，会调用对象 description 方法。是 print-object 的简写 po [self view] 3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。 4). bt：打印调用堆栈，是 thread backtrace 的简写，加 all 可打印所有 thread 的堆栈 5). br l：是 breakpoint list 的简写</p>
<h5>50、你一般是怎么用 Instruments 的？</h5>
<p>Instruments 里面工具很多，常用： 1). Time Profiler: 性能分析 2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。 3). Allocations：用来检查内存，写算法的那批人也用这个来检查。 4). Leaks：检查内存，看是否有内存泄露。</p>
<h5>51、iOS 中常用的数据存储方式有哪些？</h5>
<p>数据存储有四种方案：NSUserDefault、KeyChain、file、DB。 其中 File 有三种方式：plist、Archive（归档） DB 包括：SQLite、FMDB、CoreData</p>
<h5>52、iOS 的沙盒目录结构是怎样的？</h5>
<p>沙盒结构： 1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。 2). Documents：常用目录，iCloud 备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过） 3). Library： Caches：存放体积大又不需要备份的数据。(常用的缓存路径) Preference：设置目录，iCloud 会备份设置信息。 4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</p>
<h5>53、iOS 多线程技术有哪几种方式？</h5>
<p>答：pthread、NSThread、GCD、NSOperation</p>
<h5>54、GCD 与 NSOperation 的区别：</h5>
<p>GCD 和 NSOperation 都是用于实现多线程： GCD 基于 C 语言的底层 API，GCD 主要与 block 结合使用，代码简洁高效。 NSOperation 属于 Objective-C 类，是基于 GCD 更高一层的封装。复杂任务一般用 NSOperation 实现。</p>
<h5>55、写出使用 GCD 方式从子线程回到主线程的方法代码</h5>
<p>答：dispatch_sync(dispatch_get_main_queue(), ^{ });</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</span><br><span class="line"></span><br><span class="line">// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</span><br><span class="line">// 创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 获取全局并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); </span><br><span class="line">// 当并发队列组中的任务执行完毕后才会执行这里的代码</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 合并图片</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>56、dispatch_barrier_async（栅栏函数）的作用是什么？</h5>
<p>函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 作用： 1. 在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。 2. 避免数据竞争</p>
<p>// 1. 创建并发队列</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2.向队列中添加任务</span><br><span class="line">dispatch_async(queue, ^&#123;  // 1.2是并行的</span><br><span class="line">    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;   // 这两个是同时执行的</span><br><span class="line">    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<p>// 输出结果: 任务 1 任务 2 ——》 任务 barrier ——》任务 3 任务 4 // 其中的任务 1 与任务 2，任务 3 与任务 4 由于是并行处理先后顺序不定。</p>
<h5>57、以下代码运行结果如何？</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 只输出：1。（主线程死锁）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>58、什么是 RunLoop</h5>
<p>从字面上讲就是运行循环，它内部就是 do-while 循环，在这个循环内部不断地处理各种任务。 一个线程对应一个 RunLoop，基本作用就是保持程序的持续运行，处理 app 中的各种事件。通过 runloop，有事运行，没事就休息，可以节省 cpu 资源，提高程序性能。</p>
<p>主线程的 run loop 默认是启动的。iOS 的应用程序里面，程序启动后会有一个如下的 main() 函数</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">    	return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>59、什么是 Runtime</h5>
<p>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。</p>
<h5>60、Runtime 实现的机制是什么，怎么用，一般用于干嘛？</h5>
<p>1). 使用时需要导入的头文件 &lt;objc/message.h&gt; &lt;objc/runtime.h&gt; 2). Runtime 运行时机制，它是一套 C 语言库。 3). 实际上我们编写的所有 OC 代码，最终都是转成了 runtime 库的东西。 比如： 类转成了 Runtime 库里面的结构体等数据类型， 方法转成了 Runtime 库里面的 C 语言函数， 平时调方法都是转成了 objc_msgSend 函数（所以说 OC 有个消息发送机制） // OC 是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。 // [stu show]; 在 objc 动态编译时，会被转意为：objc_msgSend(stu, @selector(show)); 4). 因此，可以说 Runtime 是 OC 的底层实现，是 OC 的幕后执行者。</p>
<h5>61、有了 Runtime 库，能做什么事情呢？ Runtime 库里面包含了跟类、成员变量、方法相关的 API。 比如： （1）获取类里面的所有成员变量。 （2）为类动态添加成员变量。 （3）动态改变类的方法实现。 （4）为类动态添加新的方法等。 因此，有了 Runtime，想怎么改就怎么改。</h5>
<h5>62、什么是 Method Swizzle（黑魔法），什么情况下会使用？</h5>
<p>1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。 2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC 中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。 3). 在 OC 中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是 selector 的名字。利用 OC 的动态特性，可以实现在运行时偷换 selector 对应的方法实现。 4). 每个类都有一个方法列表，存放着 selector 的名字和方法实现的映射关系。IMP 有点类似函数指针，指向具体的方法实现。 5). 我们可以利用 method_exchangeImplementations 来交换 2 个方法中的 IMP。 6). 我们可以利用 class_replaceMethod 来修改类。 7). 我们可以利用 method_setImplementation 来直接设置某个方法的 IMP。 8). 归根结底，都是偷换了 selector 的 IMP。</p>
<h5>63、_objc_msgForward 函数是做什么的，直接调用它将会发生什么？</h5>
<p>答：_objc_msgForward 是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward 会尝试做消息转发。</p>
<h5>64、什么是 TCP / UDP ?</h5>
<p>TCP：传输控制协议。 UDP：用户数据协议。</p>
<p>TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。 UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。 简单的说，TCP 注重数据安全，而 UDP 数据传输快点，但安全性一般。</p>
<h5>65、通信底层原理（OSI 七层模型）</h5>
<p>OSI 采用了分层的结构化技术，共分七层： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<h5>66、介绍一下 XMPP？</h5>
<p>XMPP 是一种以 XML 为基础的开放式实时通信协议。 简单的说，XMPP 就是一种协议，一种规定。就是说，在网络上传东西，XMM 就是规定你上传大小的格式。</p>
<h5>67、OC 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建线程的方法</span><br><span class="line">- [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil]</span><br><span class="line">- [self performSelectorInBackground:nil withObject:nil];</span><br><span class="line">- [[NSThread alloc] initWithTarget:nil selector:nil object:nil];</span><br><span class="line">- dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;&#125;);</span><br><span class="line">- [[NSOperationQueue new] addOperation:nil];</span><br><span class="line"></span><br><span class="line">// 主线程中执行代码的方法</span><br><span class="line">- [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];</span><br><span class="line">- dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</span><br><span class="line">- [[NSOperationQueue mainQueue] addOperation:nil];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>68、tableView 的重用机制？</h5>
<p>答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类, 当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</p>
<h5>69、用伪代码写一个线程安全的单例模式</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       _instance = [super allocWithZone:zone];</span><br><span class="line">   &#125;);</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedData &#123;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       _instance = [[self alloc] init];</span><br><span class="line">   &#125;);</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>70、如何实现视图的变形?</h5>
<p>答：通过修改 view 的 transform 属性即可。</p>
<h5>71、在手势对象基础类 UIGestureRecognizer 的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</h5>
<p>答：UITapGestureRecognizer,UISwipeGestureRecognizer 是一次性手势, 手势发生后, 响应只会执行一次。</p>
<h5>72、字符串常用方法：</h5>
<p>NSString _str = @&quot;abc_123&quot;; NSArray <em>arr = [str componentsSeparatedByString:@&quot;</em>&quot;]; // 以目标字符串把原字符串分割成两部分，存到数组中。@[@&quot;abc&quot;, @&quot;123&quot;];</p>
<h5>73如何高性能的给 UIImageView 加个圆角?</h5>
<p>不好的解决方案：使用下面的方式会强制 Core Animation 提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。</p>
<p>self.view.layer.cornerRadius = 5.0f; self.view.layer.masksToBounds = YES;</p>
<p>正确的解决方案：使用绘图技术</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)circleImage &#123;</span><br><span class="line">    // NO代表透明</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);</span><br><span class="line">    // 获得上下文</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">    // 添加一个圆</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">    CGContextAddEllipseInRect(ctx, rect);</span><br><span class="line">    // 裁剪</span><br><span class="line">    CGContextClip(ctx);</span><br><span class="line">    // 将图片画上去</span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    // 关闭上下文</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<p>还有一种方案：使用了贝塞尔曲线 &quot;切割&quot; 个这个图片, 给 UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">imageView.center = CGPointMake(200, 300);</span><br><span class="line">UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);</span><br><span class="line">[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds</span><br><span class="line">                       cornerRadius:50] addClip];</span><br><span class="line">[anotherImage drawInRect:imageView.bounds];</span><br><span class="line">imageView.image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">[self.view addSubview:imageView];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>74你是怎么封装一个 view 的</h5>
<p>1）. 可以通过纯代码或者 xib 的方式来封装子控件 2）. 建立一个跟 view 相关的模型，然后将模型数据传给 view，通过模型上的数据给 view 的子控件赋值</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  纯代码初始化控件时一定会走这个方法</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if(self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过xib初始化控件时一定会走这个方法</span><br><span class="line"> */</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if(self = [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupUI &#123;</span><br><span class="line">    // 初始化代码</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<h5>75HTTP 协议中 POST 方法和 GET 方法有那些区别?</h5>
<ol>
<li>GET 用于向服务器请求数据，POST 用于提交数据</li>
<li>GET 请求，请求参数拼接形式暴露在地址栏，而 POST 请求参数则放在请求体里面，因此 GET 请求不适合用于验证密码等操作</li>
<li>GET 请求的 URL 有长度限制，POST 请求不会有长度限制</li>
</ol>
<h5>76请简单的介绍下 APNS 发送系统消息的机制？</h5>
<p>APNS 优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由 iOS 系统和 APNS 进行长连接替代。 APNS 的原理： 1). 应用在通知中心注册，由 iOS 系统向 APNS 请求返回设备令牌 (device Token) 2). 应用程序接收到设备令牌并发送给自己的后台服务器 3). 服务器把要推送的内容和设备发送给 APNS 4). APNS 根据设备令牌找到设备，再由 iOS 根据 APPID 把推送内容展示</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/12/iOS/UI/UI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/iOS/UI/UI/" itemprop="url">UI基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-12T12:12:42+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>UI</h1>
<h2>List</h2>
<p>&lt;a href=&quot;#UI Foundation&quot;&gt;1. UI基础要点&lt;/a&gt;</p>
<p>&lt;a href=&quot;#iOS Render Progress&quot;&gt;2. iOS 界面渲染流程&lt;/a&gt;</p>
<p>&lt;a href=&quot;#iOS Image Load And Render Progress&quot;&gt;3.iOS中图片的加载与渲染过程&lt;/a&gt;</p>
<p>&lt;a id=&quot;UI Foundation&quot;&gt;</p>
<h2>UI基础</h2>
<h2>1. UITableView/UICollectionView</h2>
<h3>1.1 重用机制</h3>
<p>一般会通过重用cell来达到节省内存的目的:通过为每个cell指定一个重用标识符(reuseIdentifier),即指定了单元格的种类,当cell滚出屏幕时,会将滚出屏幕的单元格放入重用的缓存池中，当某个未在屏幕上的单元格要显示的时候，就从这个缓存池中取出单元格进行重用。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024811.png" alt="image-20190312102829081"></p>
<h3>1.2  数据源同步</h3>
<p>如何解决tableView在多线程的情况下修改或者访问数据源的一个同步问题?</p>
<ul>
<li>并发访问 &amp; 数据拷贝</li>
<li>串行访问</li>
</ul>
<h2>2.UI事件传递和响应</h2>
<h3>CALayer 与 UIView</h3>
<ul>
<li>UIView 为CALayer提供内容，专门负责处理触摸等事件，参与响应链</li>
<li>CALayer 全权负责显示内容 contents</li>
<li>单一原则，设计模式（负责相应的功能）</li>
</ul>
<h3>事件传递</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">//返回最终响应的事件</span><br><span class="line">    //指定想要响应事件的 View, 比如点击的是 A ，可以指派 B 来响应。</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">//判断点击位置是否在当前范围内</span><br><span class="line">    //控制响应的范围，扩大 or 缩小。</span><br></pre></td></tr></table></figure></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024827.png" alt="image-20190312105858402"></p>
<ul>
<li>首先判断当前视图 !hidden &amp;$ userInteractionEnable &amp;&amp; alpha &gt; 0.01 条件通过的时候，到下一步.   否则返回nil，找不到当前视图</li>
<li>通过 pointInside 判断点击的点是否在当前范围内，为YES直接下一步.  不在则直接返回nil。</li>
<li><code>倒序遍历</code>所有子视图，同时调用 hitTest 方法，如果某一个子视图返回了对应的响应视图，这个子视图会直接作为最终的响应视图给响应方，如果为 nil 则继续遍历下一个子视图。如果全部遍历结束都返回nil，那会返回当前点击位置在当前的视图范围内的视图作为最终响应视图.......</li>
</ul>
<p>当我们点击屏幕时候的事件传递</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIApplication -&gt; UIWindow -&gt; hitTest:withEvent:</span><br></pre></td></tr></table></figure></p>
<h3>视图响应链 (注意和事件传递是倆概念)</h3>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024834.png" alt="image-20190312112027519"></p>
<h2>3 图像显示原理</h2>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024839.png" alt="image-20190312113303637"></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024844.png" alt="image-20190312112603570"></p>
<p>CPU和GPU通过总线连接，CPU中计算出的往往是bitmap位图，通过总线由合适的时机传递给GPU，GPU拿到位图后，渲染到帧缓存区FrameBuffer,然后由视频控制器根据vsync信号在指定时间之前去帧缓冲区提取内容，显示到屏幕上。</p>
<p><code>CPU工作内容:</code>layout（UI布局，文本计算），display（绘制 drawRect）,prepare(图片解码)，commit（提交位图）</p>
<p><code>GPU工作内容:</code> 顶点着色，图元装配，光栅化，片段着色，片段处理，最后提交帧缓冲区</p>
<h3>3.1  UI 卡顿、掉帧原理</h3>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024849.png" alt="image-20190312140156990"></p>
<p>在规定的16.7ms内，在下一个VSync信号到来之前，CPU和GPU并没有共同完成下一帧视频的合成，就会出现掉帧、卡顿。</p>
<h5>滑动优化方案思路：</h5>
<ul>
<li>
<p>CPU：</p>
<ul>
<li>
<p>对象的创建、调整、销毁可以放在子线程中去做ASDK；</p>
</li>
<li>
<p>预排班。布局计算、文本计算等事先放到子线程中去做；</p>
</li>
<li>
<p>使用轻量级对象，比如CALayer代替UIView</p>
</li>
<li>
<p>预渲染。文本等异步绘制，图片编解码等。</p>
</li>
<li>
<p>控制并发线程数量</p>
</li>
<li>
<p>减少重复计算布局，减少修改frame等</p>
</li>
<li>
<p>autolayout比frame更消耗资源</p>
</li>
<li>
<p>可以让图片的size跟frame一致</p>
</li>
</ul>
</li>
<li>
<p>GPU：</p>
<ul>
<li>
<p>纹理渲染。避免离屏渲染</p>
</li>
<li>
<p>视图混合。减少视图层级的复杂性，减少透明视图；不透明的opaque设置为YES</p>
</li>
<li>
<p>GPU能处理的最大纹理是4096 * 4096，一旦超过这个尺寸就会调用CPU进行资源处理，所以纹理尽量不要超过这个尺寸</p>
</li>
</ul>
</li>
</ul>
<h3>4.UIView的绘制原理</h3>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024854.png" alt="image-20190312141642996"></p>
<p><code>[UIView setNeedsDisplay]</code> 并没有发生当前视图立即绘制工作,打上需要重绘的脏标记，最后是在某个时机完成</p>
<p><code>[UIView setLayoutIfNeed]</code> 立即重新布局视图</p>
<p>当我们调用UIView的<code>setNeedsDisplay</code>的方法时候，会调用<code>layer</code>的同名方法，相当于在当前<code>layer</code>打上绘制标记，在当前<code>runloop</code>将要结束的时候，才会调用CALayer的<code>display</code>方法进入到真正的绘制当中。</p>
<p>CALayer的<code>display</code>方法中，首先会判断layer的delegate方法<code>displayLayer：</code>是否实现，如果代理没有响应这个方法，则进入到系统绘制流程；如果代理响应了这个方法，则进入到异步绘制流程</p>
<h4>4.1系统绘制流程</h4>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024857.png" alt="image-20190312142115333"></p>
<p>在CALayer内部，系统会创建一个backingStore（可以理解为CGContextRef，drawRect中取到的currentRef就是这个东西），然后layer回判断是否有delegate，如果没有代理，就调用CALayer的<code>drawInContext：</code>方法；如果有代理，则调用layer代理的<code>drawLayer:inContext:</code>方法，这一步发生在系统内部，然后在合适的时间给与我们回调一个熟悉的UIView的<code>drawRect：</code>方法。也就是在系统内部的绘制之上，允许我们再做一些额外的绘制。最后CALayer把backting store（位图）传给GPU。</p>
<h4>4.2 异步绘制流程</h4>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024902.png" alt="image-20190312142425272"></p>
<p>layer的delegate如果实现了<code>displayLayer:</code>方法，就会进入到异步绘制的流程。在异步绘制的过程中，需要代理来生成对应的bitmap位图文件，并把此bitmap作为layer的contents属性</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024910.png" alt="image-20190312142514299"></p>
<h4>4.3 离屏渲染</h4>
<p>当设置某些UI图层属性时候，如果指定为被未预合成之前，不能直接显示在屏幕上的时候，就触发了离屏渲染。离屏渲染是基于GPU层面上的，指GPU在当前屏幕缓冲区外开辟了一个缓冲区，进行渲染操作。</p>
<h5>何时会触发离屏渲染：</h5>
<ul>
<li>设置图层圆角的时候，且跟maskToBounds或者clipToBounds同时使用；</li>
<li>设置图层蒙版</li>
<li>阴影</li>
<li>光栅化</li>
</ul>
<h5>为何要避免离屏渲染?</h5>
<p>离屏渲染发生在GPU层面上，因为离屏渲染使GPU触发Opengl多通道渲染管线，产生额外开销，所以要避免。 在触发离屏渲染时候，会增加GPU工作量，增加GPU工作量，可能会导致GPU和CPU工作耗时的总耗时超出Vsync信号时间，导致UI卡顿或者掉帧。</p>
<p>&lt;a id=&quot;iOS Render Progress&quot;&gt;</p>
<h2>iOS 界面渲染流程</h2>
<p><img src="http://img.isylar.com/media/15420320733034-1.jpg" alt="15420320733034"></p>
<ol>
<li>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层级关系，查询是否有重写 <code>drawRect:</code> 或 <code>drawLayer:inContext:</code>方法，<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong></li>
<li>CPU 会将处理视图和图层的层级关系打包，通过 IPC（内部处理通信）通道提交给渲染服务，渲染服务由 OpenGL ES 和 GPU 组成。</li>
<li>渲染服务首先将图层数据交给 OpenGL ES 进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</li>
<li>最后，将最终要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</li>
</ol>
<blockquote>
<p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p>
</blockquote>
<p>&lt;a id=&quot;iOS Image Load And Render Progress&quot;&gt;</p>
<h2>iOS中图片的加载与渲染过程</h2>
<ol>
<li>要访问的图片文件通过系统调用 <code>mmap()</code> 映射到内存，通过 <code>CGImageSourceRef</code> 访问图像数据，创建<code>CGImageRef</code>。</li>
</ol>
<ul>
<li>传统操作系统的I/O操作为标准I/O，即缓存I/O。在这种I/O模型下，数据先从磁盘拷贝到内核空间的缓冲区，然后从内核空间缓冲区拷贝到用户的内存空间。这种方式的优点是减少了磁盘操作，提高性能。但因为数据在传输过程中需要在用户内存空间和内核空间间进行多次数据拷贝操作，造成很大的CPU及内存开销。</li>
<li><code>mmap()</code> 将硬盘数据直接映射到虚拟内存中，应用可以直接访问虚拟内存中对应的地址来读取数据，避免了数据在内核空间和用户空间的相互拷贝，效率更高。在<strong>使用这些数据时，虚拟内存管理系统才会根据缺页加载的机制从磁盘加载对应的数据块到物理内存，在这之前不会消耗用户空间的内存。</strong> iOS中，使用 imageNamed 或者imageWithContentsOfFile 时，系统会调用 mmap() 将图片文件映射到虚拟内存，并创建 CGImageRef 用于后续访问图片数据。</li>
</ul>
<ol start="2">
<li>在主线程中，将图片数据赋值给 UIImageView 。在保存图片时，为了节省空间，通常会将图片编码（压缩）后再进行存储。<strong>如果读取的图片数据为压缩后的数据的话，那就需要对其进行解码成位图（Bitmap）数据。</strong> 不同加载图片的方式，在这一步的操作上会有一定的差异。</li>
</ol>
<ul>
<li><code>imageNamed:</code> 会在图片第一次渲染到屏幕上的时候进行解码，并缓存解码后的图片数据。缓存数据存储在全局缓存中，不会随着UIImag的释放而释放。</li>
<li><code>imageWithContentsOfFile:</code> 或 <code>imageWithData:</code> 同样会在图片第一次渲染到屏幕上的时候进行解码。底层会调用到 <code>CGImageSourceCreateWithData()</code> 方法，该方法可以指定是否要缓存解码后的数据，在64位机器上默认需要缓存（<code>kCGImageSourceShouldCache</code>）。与上面的方法不同，这种方式创建的缓存会随着UIImage的释放而被释放掉。</li>
</ul>
<ol start="3">
<li>手动调用 <code>CGImageSourceCreateWithData()</code> 方法可以指定是否需要缓存（<code>kCGImageSourceShouldCache</code>），之后再调用 <code>CGImageSourceCreateImageAtIndex()</code> 可以设置是否需要立即进行解码（<code>kCGImageSourceShouldCacheImmediately</code>），如果设置为不需要立刻解码，则会在<strong>将图片渲染到屏幕上时才进行解码。</strong>（设置为立即解码会阻塞主线程，造成性能问题，详见 https://www.objc.io/issues/5-ios7/iOS7-hidden-gems-and-workarounds/）</li>
<li>UIImageView 的图层树（Layer Tree）发生变化，会生成一个 <code>Implicit Transaction</code>，这个<code>transaction</code>会自动在主线程的下一个 Runloop 进行提交。（<code>Explicit Transaction</code> 由显式调用 begin() 和 commit() 方法触发生成。）</li>
<li>下一个Main Runloop中，Core Animation会提交这个 Implicit Transaction。如果用户内存中的位图数据没<strong>有字节对齐</strong> ，出于渲染性能考虑， <strong>Core Animation会对数据进行拷贝，以进行字节对齐。</strong> 之后，GPU会渲染对齐后的位图数据，展示在屏幕上。</li>
</ol>
<h2>Reference:</h2>
<p><a href="http://blog.corneliamu.com/archives/95" target="_blank" rel="noopener">1.iOS中图片的加载与渲染过程</a></p>
<p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">2.iOS 保持界面流畅的技巧</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2018/07/10/iOS/Runtime/Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/iOS/Runtime/Runtime/" itemprop="url">Runtime</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-10T12:12:42+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>Runtime机制</h1>
<h2>List</h2>
<p>&lt;a href=&quot;#Runtime Foundation&quot;&gt;1. Runtime基础&lt;/a&gt;</p>
<p>&lt;a href=&quot;#Runtime Key Points&quot;&gt;2.Runtime一些考点与知识点&lt;/a&gt;</p>
<p>&lt;a href=&quot;#Runtime Reference&quot;&gt;3.Runtime Reference&lt;/a&gt;</p>
<p>&lt;a id=&quot;Runtime Foundation&quot;&gt;</p>
<h2>Runtime基础</h2>
<p>Runtime内容流程</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-022544.jpg" alt></p>
<h2>1.对象和类数据结构</h2>
<p>一个类的内部结构如下,</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085229.jpg" alt="image-20190324153451659"></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023218.jpg" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085240.jpg" alt="image-20190324154051666"></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085336.jpg" alt="image-20190324154130013"></p>
<ul>
<li>superClass 指向当前类的父类</li>
<li>cache_t 提供消息传递过程当中的缓存方法查找 ， 实质上是装满了 bucket_t 的一个 <strong>hash 表</strong>。因为散列表检索起来更快，</li>
<li>class_data_bits_t 类的基础信息，包含了类的方法列表，协议列表等。</li>
</ul>
<p>method_t是一个方法的封装,里面包括了名称(SEL),返回值,参数,与函数体(实现)</p>
<h4>1.1 class_data_bits_t 结构体</h4>
<p><code>class_data_bits_t</code>结构体中只有一个64位的指针bits，它相当于<code>class_rw_t</code>指针加上 rr/alloc 等标志位。其中<code>class_rw_t</code>指针存在于4~47位（从1开始计）</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023930.png" alt></p>
<p>class_rw_t结构体的定义如下</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">		//这个是单个类(基本原类)的结构体</span><br><span class="line">  //里面与 class_rw_t结构一样</span><br><span class="line">  //也是包括了方法，属性与协议</span><br><span class="line">  </span><br><span class="line">    method_array_t methods;</span><br><span class="line">  //重点看这里</span><br><span class="line">  //方法数组.</span><br><span class="line">  //其实是该类与该类的分类所有方法的集合</span><br><span class="line">  //下 属性与协议数组相同 意思</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p>
<h4>1.2 class_ro_t 结构体</h4>
<p>class_ro_t与class_rw_t的最大区别在于一个是只读的，一个是可读写的，实质上ro就是readonly的简写，rw是readwrite的简写。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>class_ro_t</code>在<strong>内存中是不可变</strong>的。**[所以说扩展编译器已经决定了内存结构不能添加属性，只能通过关联添加]**在运行期间，动态给类添加方法，实质上是更新class_rw_t的methods列表。</p>
<h4>1.3 cache_t</h4>
<p>用于缓存方法</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-24-085245.jpg" alt="image-20190324153654016"></p>
<h2>2.类对象与元类对象</h2>
<h4>2.1 metaclass &amp; class</h4>
<p>在objc中，class存储类的实例方法（-），meta class存储类的类方法（+），class的isa指针指向meta class。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023919.jpg" alt></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1dxftgghzj30ad05gwf3.jpg" alt="image-20190324154213040"></p>
<p>每个类<strong>仅有一个类对象</strong>，而每个类对象<strong>仅有一个与之相关的元类</strong>。当你发出一个类似 <code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend() 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>
<p>看一个例子:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface CustomObject : NSObject</span><br><span class="line">-(NSString *)returnMeHelloWorld;</span><br><span class="line">@end</span><br><span class="line">@implementation CustomObject</span><br><span class="line"></span><br><span class="line">-(NSString *)returnMeHelloWorld&#123;</span><br><span class="line">    return @&quot;hello world&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>先只看调用这一行:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString * helloWorld =  [obj returnMeHelloWorld];</span><br></pre></td></tr></table></figure></p>
<ol>
<li>编译成如下<code>id objc_msgSend(self,@selector(returnMeHelloWorld:));</code></li>
<li>在self中沿着<code>isa</code>找到<code>CustomObject</code>的类对象</li>
<li>类对象查找自己的方法list，找到对应的方法执行体Method[还要缓存一下]</li>
<li>把参数传递给IMP实际指向的执行代码</li>
<li>代码执行返回结果给helloWorld</li>
</ol>
<h2>3.消息传递</h2>
<p>OC 是一门动态语言，函数调用变成了消息发送，在编译期不能知道要调用哪个函数。所以 Runtime 无非就是去解决如何在运行时期找到调用方法这样的问题</p>
<blockquote>
<p>instance -&gt; class -&gt; method -&gt; SEL -&gt; IMP -&gt; 实现函数</p>
</blockquote>
<p>根据<code>isa</code>特性可以解释消息传递与寻找方法列表原理</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-061439.jpg" alt></p>
<p>这就是消息传递的一个流程，首先查缓存，无缓存，查方法列表，依然没命中，再顺次查找各个父类方法列表，如果都没有名字，就转到消息转发流程</p>
<ul>
<li>在缓存查找阶段是 哈希查找</li>
<li>当前类方法查找 ， 如果是已排序的列表，就采用二分查找,没排序的采用一般遍历</li>
<li>逐级父类方法查找 ，是根据 superClass 指针逐级遍历每一个父类</li>
</ul>
<p>引申一个考点</p>
<p><strong>Q:OC中向一个nil对象发送消息将会发生什么?为什么?</strong></p>
<p><strong>A:</strong> nil的定义是null pointer to object-c object，指的是一个OC对象指针为空，本质就是(id)0，是OC对象的字面0值.OC中给空指针发消息不会崩溃的语言特性，<strong>原因是OC的函数调用都是通过objc_msgSend进行消息发送来实现的</strong>，相对于C和C++来说，对于空指针的操作会引起Crash的问题，<strong>而objc_msgSend会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回</strong>，所以不会出现问题。</p>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>
<h3>3.1 消息转发</h3>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-061727.jpg" alt></p>
<p>&lt;a id=&quot;Runtime Key Points&quot;&gt;</p>
<h2>Runtime更多知识点</h2>
<h4>1.方法缓存存在什么地方？</h4>
<p>在类的定义里就有cache字段，没错，类的所有缓存都存在metaclass上，所以每个类都只有一份方法缓存，而<strong>不是每一个类的object都保存一份</strong></p>
<h4>2.父类方法的缓存只存在父类么，还是子类也会缓存父类的方法？</h4>
<p>即便是从父类取到的方法，<strong>也会存在类本身的方法缓存里</strong>。而当用一个父类对象去调用那个方法的时候，也会在父类的metaclass里缓存一份。</p>
<h4>3.为什么 类的方法列表 不直接做成散列表呢，做成list，还要单独缓存，多费事？</h4>
<ul>
<li>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。</li>
<li>list的方法还保存了除了selector和imp之外其他很多属性</li>
<li>散列表是有空槽的，会浪费空间</li>
</ul>
<p>&lt;a id=&quot;Runtime Reference&quot;&gt;</p>
<h2>Reference</h2>
<p><a href="https://www.jianshu.com/p/0a4e5b944d7d" target="_blank" rel="noopener">1.Objective-C Runtime机制简析(Article文件夹有收藏)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">2.Objective-C Runtime</a></p>
<p><a href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html" target="_blank" rel="noopener">3.深入理解 Objective-C：方法缓存</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">caicoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">caicoder</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
