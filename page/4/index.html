<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="caicoder的博客">
<meta property="og:url" content="https://caicoder.github.io/page/4/index.html">
<meta property="og:site_name" content="caicoder的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="caicoder的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://caicoder.github.io/page/4/">





  <title>caicoder的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">caicoder的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/07/16/NSFileManager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/16/NSFileManager/" itemprop="url">NSFileManager</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-16T12:12:42+08:00">
                2017-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><a href="#1">Creating a File Manager</a></li>
<li><a href="#2">Locating System Directories</a></li>
<li><a href="#3">Locating Application Group Container Directories</a></li>
<li><a href="#4">Discovering Directory Contents</a></li>
<li><a href="#5">Creating and Deleting Items</a></li>
<li><a href="#6">Moving and Copying Items</a></li>
<li><a href="#7">Managing iCloud-Based Items</a></li>
<li><a href="#8">Creating Symbolic and Hard Links</a></li>
<li><a href="#9">Determining Access to Files</a></li>
<li><a href="#10">Getting and Setting Attributes</a></li>
<li><a href="#11">Getting and Comparing File Contents</a></li>
<li><a href="#12">Getting the Relationship Between Items</a></li>
<li><a href="#13">Converting File Paths to Strings</a></li>
<li><a href="#14">Managing the Delegate</a></li>
<li><a href="#15">Managing the Current Directory</a></li>
<li><a href="#16">Deprecated Methods</a></li>
</ol>
<hr>
<p>NSFileManager(Swift中是FileManager)帮助我们快速访问管理文件系统。通过它我们可以对文件进行定位、复制、移动和删除等操作。</p>
<h1 id="1-Creating-a-File-Manager"><a href="#1-Creating-a-File-Manager" class="headerlink" title="1 Creating a File Manager"></a><a id="1">1 Creating a File Manager</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取共享的NSFileManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultManager</span>() -&gt; <span class="title">NSFileManager</span></span></span><br></pre></td></tr></table></figure>
<h1 id="2-Locating-System-Directories"><a href="#2-Locating-System-Directories" class="headerlink" title="2 Locating System Directories"></a><a id="2">2 Locating System Directories</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速获取目录</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">URLsForDirectory</span><span class="params">(directory: NSSearchPathDirectory, inDomains domainMask: NSSearchPathDomainMask)</span></span> -&gt; [<span class="type">NSURL</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 文件夹内快速创建文件夹</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter directory : .ItemReplacementDirectory</span></span><br><span class="line"><span class="comment">/// - parameter inDomain : .UserDomainMask</span></span><br><span class="line"><span class="comment">/// - parameter appropriateForURL : 目标目录</span></span><br><span class="line"><span class="comment">/// - parameter create : 是否创建</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - returns: void</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">URLForDirectory</span><span class="params">(directory: NSSearchPathDirectory, inDomain domain: NSSearchPathDomainMask, appropriateForURL url: NSURL?, create shouldCreate: Bool)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSURL</span></span><br></pre></td></tr></table></figure>
<h1 id="3-Locating-Application-Group-Container-Directories"><a href="#3-Locating-Application-Group-Container-Directories" class="headerlink" title="3 Locating Application Group Container Directories"></a><a id="3">3 Locating Application Group Container Directories</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取应用容器目录</span></span><br><span class="line"><span class="comment">/// 定位应用组目录，需在https://idmsa.apple.com/IDMSWebAuth/authenticate配置</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter groupIdentifier : 容器ID</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - returns: NSURL?</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">containerURLForSecurityApplicationGroupIdentifier</span><span class="params">(groupIdentifier: String)</span></span> -&gt; <span class="type">NSURL?</span></span><br></pre></td></tr></table></figure>
<h1 id="4-Discovering-Directory-Contents"><a href="#4-Discovering-Directory-Contents" class="headerlink" title="4 Discovering Directory Contents"></a><a id="4">4 Discovering Directory Contents</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取一级目录内的内容</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter url : 目标路径</span></span><br><span class="line"><span class="comment">/// - parameter includingPropertiesForKeys : 关键字</span></span><br><span class="line"><span class="comment">/// - parameter options : 枚举选项，NSDirectoryEnumerationOptions.SkipsHiddenFiles</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - returns: [NSURL]</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">contentsOfDirectoryAtURL</span><span class="params">(url: NSURL, includingPropertiesForKeys keys: [String]?, options mask: NSDirectoryEnumerationOptions)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">NSURL</span>] </span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">contentsOfDirectoryAtPath</span><span class="params">(path: String)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 枚举获取目录下内容</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">enumeratorAtURL</span><span class="params">(url: NSURL, includingPropertiesForKeys keys: [String]?, options mask: NSDirectoryEnumerationOptions, errorHandler handler: <span class="params">(<span class="params">(NSURL, NSError)</span></span></span></span> -&gt; <span class="type">Bool</span>)?) -&gt; <span class="type">NSDirectoryEnumerator?</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">enumeratorAtPath</span><span class="params">(path: String)</span></span> -&gt; <span class="type">NSDirectoryEnumerator?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回所有路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subpathsAtPath</span><span class="params">(path: String)</span></span> -&gt; [<span class="type">String</span>]?</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subpathsOfDirectoryAtPath</span><span class="params">(path: String)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<h1 id="5-Creating-and-Deleting-Items"><a href="#5-Creating-and-Deleting-Items" class="headerlink" title="5 Creating and Deleting Items"></a><a id="5">5 Creating and Deleting Items</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建文件夹</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">createDirectoryAtURL</span><span class="params">(url: NSURL, withIntermediateDirectories createIntermediates: Bool, attributes: [String : AnyObject]?)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">createDirectoryAtPath</span><span class="params">(path: String, withIntermediateDirectories createIntermediates: Bool, attributes: [String : AnyObject]?)</span></span> <span class="keyword">throws</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 创建文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">createFileAtPath</span><span class="params">(path: String, contents data: NSData?, attributes attr: [String : AnyObject]?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 删除文件</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeItemAtPath</span><span class="params">(path: String)</span></span> <span class="keyword">throws</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 替换数据内容</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">replaceItemAtURL</span><span class="params">(originalItemURL: NSURL, withItemAtURL newItemURL: NSURL, backupItemName: String?, options: NSFileManagerItemReplacementOptions, resultingItemURL resultingURL: AutoreleasingUnsafeMutablePointer&lt;NSURL?&gt;)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<h1 id="6-Moving-and-Copying-Items"><a href="#6-Moving-and-Copying-Items" class="headerlink" title="6 Moving and Copying Items"></a><a id="6">6 Moving and Copying Items</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 复制文件</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">copyItemAtPath</span><span class="params">(srcPath: String, toPath dstPath: String)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">copyItemAtURL</span><span class="params">(srcURL: NSURL, toURL dstURL: NSURL)</span></span> <span class="keyword">throws</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 移动文件</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">moveItemAtPath</span><span class="params">(srcPath: String, toPath dstPath: String)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">moveItemAtURL</span><span class="params">(srcURL: NSURL, toURL dstURL: NSURL)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<h1 id="7-Managing-iCloud-Based-Items"><a href="#7-Managing-iCloud-Based-Items" class="headerlink" title="7 Managing iCloud-Based Items"></a><a id="7">7 Managing iCloud-Based Items</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取iCloud身份标识符</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</span><br><span class="line"><span class="meta">@NSCopying</span> <span class="keyword">public</span> <span class="keyword">var</span> ubiquityIdentityToken: <span class="class"><span class="keyword">protocol</span>&lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSObjectProtocol</span>&gt;? </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据iCloud容器标识符，创建容器路径</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">URLForUbiquityContainerIdentifier</span><span class="params">(containerIdentifier: String?)</span></span> -&gt; <span class="type">NSURL?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标路径是否存储在iCloud</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">isUbiquitousItemAtURL</span><span class="params">(url: NSURL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 移动文件到云中</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter flag : true移动到云中,false从云中删除</span></span><br><span class="line"><span class="comment">/// - parameter itemAtURL : 本地路径</span></span><br><span class="line"><span class="comment">/// - parameter destinationURL : 云路径</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - returns: void</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setUbiquitous</span><span class="params">(flag: Bool, itemAtURL url: NSURL, destinationURL: NSURL)</span></span> <span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 从云中下载文件</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">startDownloadingUbiquitousItemAtURL</span><span class="params">(url: NSURL)</span></span> <span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除云对应的本地副本</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">evictUbiquitousItemAtURL</span><span class="params">(url: NSURL)</span></span> <span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 生成云的url，可在浏览器中下载</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">URLForPublishingUbiquitousItemAtURL</span><span class="params">(url: NSURL, expirationDate outDate: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSURL</span></span><br></pre></td></tr></table></figure>
<h1 id="8-Creating-Symbolic-and-Hard-Links"><a href="#8-Creating-Symbolic-and-Hard-Links" class="headerlink" title="8 Creating Symbolic and Hard Links"></a><a id="8">8 Creating Symbolic and Hard Links</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建软连接</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">createSymbolicLink</span><span class="params">(atPath path: String, withDestinationPath destPath: String)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">createSymbolicLink</span><span class="params">(at url: URL, withDestinationURL destURL: URL)</span></span> <span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建硬连接</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">linkItem</span><span class="params">(atPath srcPath: String, toPath dstPath: String)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">linkItem</span><span class="params">(at srcURL: URL, to dstURL: URL)</span></span> <span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取软连接对应的实际地址</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">destinationOfSymbolicLink</span><span class="params">(atPath path: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<h1 id="9-Determining-Access-to-Files"><a href="#9-Determining-Access-to-Files" class="headerlink" title="9 Determining Access to Files"></a><a id="9">9 Determining Access to Files</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径对应的文件或文件夹是否存在</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">fileExists</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">Bool</span>  </span><br><span class="line"><span class="comment">// 路径对应的文件或文件夹是否存在，isDirectory对应是否为目录</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">fileExists</span><span class="params">(atPath path: String, isDirectory: UnsafeMutablePointer&lt;ObjCBool&gt;?)</span></span> -&gt; <span class="type">Bool</span>   </span><br><span class="line"><span class="comment">// 能否读取文件</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">isReadableFile</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="comment">// 能否写入文件</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">isWritableFile</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="comment">// 是否为可执行文件</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">isExecutableFile</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">// 能否删除文件</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">isDeletableFile</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<h1 id="10-Getting-and-Setting-Attributes"><a href="#10-Getting-and-Setting-Attributes" class="headerlink" title="10 Getting and Setting Attributes"></a><a id="10">10 Getting and Setting Attributes</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">displayName</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="comment">// 路径上的文件夹名</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">componentsToDisplay</span><span class="params">(forPath path: String)</span></span> -&gt; [<span class="type">String</span>]?</span><br><span class="line"><span class="comment">// 获取文件属性</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">attributesOfItem</span><span class="params">(atPath path: String)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="comment">// 获取文件所处系统的相关文件属性（如剩余存储空间）</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">attributesOfFileSystem</span><span class="params">(forPath path: String)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>]</span><br><span class="line"><span class="comment">// 设置文件属性</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">setAttributes</span><span class="params">(<span class="number">_</span> attributes: [FileAttributeKey : <span class="keyword">Any</span>], ofItemAtPath path: String)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<h1 id="11-Getting-and-Comparing-File-Contents"><a href="#11-Getting-and-Comparing-File-Contents" class="headerlink" title="11 Getting and Comparing File Contents"></a><a id="11">11 Getting and Comparing File Contents</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件内容</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">contents</span><span class="params">(atPath path: String)</span></span> -&gt; <span class="type">Data?</span></span><br><span class="line"><span class="comment">// 判断文件内容是否相同</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">contentsEqual</span><span class="params">(atPath path1: String, andPath path2: String)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<h1 id="12-Getting-the-Relationship-Between-Items"><a href="#12-Getting-the-Relationship-Between-Items" class="headerlink" title="12 Getting the Relationship Between Items"></a><a id="12">12 Getting the Relationship Between Items</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取路径之间的关系</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">getRelationship</span><span class="params">(<span class="number">_</span> outRelationship: UnsafeMutablePointer&lt;FileManager.URLRelationship&gt;, ofDirectoryAt directoryURL: URL, toItemAt otherURL: URL)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">// 获取路径是否在某容器中</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">getRelationship</span><span class="params">(<span class="number">_</span> outRelationship: UnsafeMutablePointer&lt;FileManager.URLRelationship&gt;, of directory: FileManager.SearchPathDirectory, <span class="keyword">in</span> domainMask: FileManager.SearchPathDomainMask, toItemAt url: URL)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<h1 id="13-Converting-File-Paths-to-Strings"><a href="#13-Converting-File-Paths-to-Strings" class="headerlink" title="13 Converting File Paths to Strings"></a><a id="13">13 Converting File Paths to Strings</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径转C字符串</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">fileSystemRepresentation</span><span class="params">(withPath path: String)</span></span> -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Int8</span>&gt;</span><br><span class="line"><span class="comment">// C字符串转路径</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">string</span><span class="params">(withFileSystemRepresentation str: UnsafePointer&lt;Int8&gt;, length len: Int)</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<h1 id="14-Managing-the-Delegate"><a href="#14-Managing-the-Delegate" class="headerlink" title="14 Managing the Delegate"></a><a id="14">14 Managing the Delegate</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理监听</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">2.0</span>, *)</span><br><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">open</span> <span class="keyword">var</span> delegate: <span class="type">FileManagerDelegate?</span></span><br></pre></td></tr></table></figure>
<h1 id="15-Managing-the-Current-Directory"><a href="#15-Managing-the-Current-Directory" class="headerlink" title="15 Managing the Current Directory"></a><a id="15">15 Managing the Current Directory</a></h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改当前工作目录为指定目录</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">changeCurrentDirectoryPath</span><span class="params">(<span class="number">_</span> path: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">// 获取当前工作目录</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> currentDirectoryPath: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>&#160;</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/07/15/Article/贝聊 IAP 实战之满地是坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/Article/贝聊 IAP 实战之满地是坑/" itemprop="url">贝聊 IAP 实战之满地是坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T12:12:42+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文地址 <a href="https://juejin.im/post/5a3b14f36fb9a045104aa6c8" target="_blank" rel="noopener">https://juejin.im/post/5a3b14f36fb9a045104aa6c8</a></p>
</blockquote>
<blockquote>
<p>注意: 文章中讨论的 IAP 是指使用苹果内购购买消耗性的项目。</p>
</blockquote>
<p>这次为大家带来我司 IAP 的实现过程详解，鉴于支付功能的重要性以及复杂性，文章会很长，而且支付验证的细节也关系重大，所以这个主题会包含三篇。</p>
<blockquote>
<p>第一篇：<a href="https://juejin.im/post/5a3b14f36fb9a045104aa6c8" target="_blank" rel="noopener">[iOS] 贝聊 IAP 实战之满地是坑</a>，这一篇是支付基础知识的讲解，主要会详细介绍 IAP，同时也会对比支付宝和微信支付，从而引出 IAP 的坑和注意点。</p>
<p>第二篇：<a href="https://juejin.im/post/5a3b164e6fb9a0450e76466b" target="_blank" rel="noopener">[iOS] 贝聊 IAP 实战之见坑填坑</a>，这一篇是高潮性的一篇，主要针对第一篇文章中分析出的 IAP 的问题进行具体解决。</p>
<p>第三篇：<a href="https://juejin.im/post/5a3b169151882521033469b4" target="_blank" rel="noopener">[iOS] 贝聊 IAP 实战之订单绑定</a>，这一篇是关键性的一篇，主要讲述作者探索将自己服务器生成的订单号绑定到 IAP 上的过程。</p>
</blockquote>
<p>不用担心，我从来不会只讲原理不留源码，我已经将我司的源码整理出来，你使用时只需要拽到工程中就可以了，下面开始我们的内容 。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbeiliao-mobile%2FBLIAP" target="_blank" rel="noopener">源码在这里。</a></p>
<h2 id="01-题外话"><a href="#01-题外话" class="headerlink" title="01. 题外话"></a>01. 题外话</h2><p>今年上半年的公众号打赏事件，大家可还记得？我们对苹果强收过路费的行为愤懑，也为微信可惜不已，此事最后以腾讯高管团队访问苹果画上句号。显然，协商结果两位老板以及他们的团队都很满意。</p>
<h2 id="02-熟悉的支付宝和微信支付"><a href="#02-熟悉的支付宝和微信支付" class="headerlink" title="02. 熟悉的支付宝和微信支付"></a>02. 熟悉的支付宝和微信支付</h2><p>仔细看一下下面这张图，这是我们每次在买早餐使用支付宝支付的流程图。下面我们来一步一步看一下每一步对应的操作原理。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-030039.jpg" alt></p>
<blockquote>
<p><strong>第一步</strong>：我们的 APP 发起一笔支付交易，此时，第一件事，我们要去我们自己的服务器上创建一个订单信息。同时服务器会组装好一笔交易交给我们。关于组装交易信息，有两种做法，第一种就是支付宝推荐我们做的，由我们服务器来组装交易信息，服务器加密交易信息，并保存签名信息；另一种做法是，服务器返回商品信息给 APP，由 APP 来组装交易信息，并进行加密处理等操作。显然我们应该采用第一种方式。</p>
<p><strong>第二步</strong>：服务器创建好交易信息以后，返回给 APP，APP 不对交易信息做处理。</p>
<p><strong>第三步</strong>：APP 拿到交易信息，开始调起支付宝的 SDK，支付宝的 SDK 把交易信息传给支付宝的服务器。</p>
<p><strong>第四步</strong>：验证通过以后，支付宝服务器会告诉支付宝 SDK 验证通过。</p>
<p><strong>第五步</strong>：验证通过以后，我们的 APP 会调起支付宝 APP，跳转到支付宝 APP。</p>
<p><strong>第六步</strong>：在支付宝 APP 里，用户输入密码进行交易，和支付宝服务器进行通讯。</p>
<p><strong>第七步</strong>：支付成功，支付宝服务器回调支付宝 APP。</p>
<p><strong>第八步</strong>：支付宝回到我们自己的 APP，并通过 <code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code> 方法处理支付宝的回调结果，对应的进行刷新 UI 等操作。</p>
<p>第九步：支付宝服务器会回调我们的服务器并把收据传给我们服务器，如果我们的服务器没有确认已经收到支付宝的收据信息，那么支付宝服务器就会一直回调我们的服务器，只是回调时间间隔会越来越久。</p>
<p><strong>第十步</strong>：我们的服务器收到支付宝的回调，并回调支付宝，确认已经收到收据信息，此时早餐买完了。</p>
</blockquote>
<p>支付宝的支付流程讲完了，那微信支付也讲完了，因为它们流程相似。</p>
<h2 id="03-坑爹的-IAP-支付"><a href="#03-坑爹的-IAP-支付" class="headerlink" title="03. 坑爹的 IAP 支付"></a>03. 坑爹的 IAP 支付</h2><p>IAP 坑爹之处从以下两个方面来理解。</p>
<p>第一方面，APP 不接 IAP 审核不让过。接不接 IAP，苹果不是和你商量，而是强制要求，爸爸说怎么样，就怎么样。当然，这篇文章解决不了这个问题，所以也只是说说而已。上面说了微信公众号的事情，虽然它不是 IAP 的事情，但是实质上都属于强收过路费的行为。</p>
<p>第二方面，坑开发人员。下面开始数坑。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-030102.jpg" alt></p>
<p>只有 8 步，比支付宝少 2 步，对不对？看起来比支付宝还简单，有木有？</p>
<blockquote>
<p><strong>第一步</strong>：用户开始购买，首先会去我们自己的服务器创建一个交易订单，返回给 APP。</p>
<p><strong>第二步</strong>：APP 拿到交易信息，然后开始调起 IAP 服务创建订单，并把订单推入支付队列。</p>
<p><strong>第三步</strong>：IAP 会和 IAP 服务器通讯，让用户确认购买，输入密码。</p>
<p><strong>第四步</strong>：IAP 服务器回调 APP，通知购买成功，并把收据写入到 APP 沙盒中。</p>
<p><strong>第五步</strong>：此时，APP 应该去获取沙盒中的收据信息（一段 Base 64 编码的数据），并将收据信息上传给服务器。</p>
<p><strong>第六步</strong>：服务器拿到收据以后，就应该去 IAP 服务器查询这个收据对应的已付款的订单号。</p>
<p><strong>第七步</strong>：我们自己的服务器拿到这个收据对应的已付款的订单号以后，就去校验当前的已付款订单中是否有要查询的那一笔，如果有，就告诉 APP。</p>
<p><strong>第八步</strong>：APP 拿到查询结果，然后把这笔交易给 finish 掉。</p>
</blockquote>
<h2 id="04-对比支付宝和-IAP"><a href="#04-对比支付宝和-IAP" class="headerlink" title="04. 对比支付宝和 IAP"></a>04. 对比支付宝和 IAP</h2><p>没啥大毛病，对吧？现在来详细分析一下。</p>
<p>由于移动端所处的网络环境远远比服务端要复杂，所以，最大可能出现问题的是与移动端的通讯上。对于支付宝，只要移动端确实付款完成，那么接下来的验证工作都是服务器于服务器之间的通讯。这样一来，只要用户确实产生了一笔交易，那么接下来的验证就变得可靠的多，而且支付宝服务器会一直回调我们的服务器，交易的可靠性得到了极大的保证。</p>
<p>同样，我们再来看看 IAP，交易是一样的。但是<strong>验证交易这一环需要移动端来驱动我们自己的服务器来进行查询，这是第一个坑，先记一笔</strong>。另外一点，<strong>IAP 的服务器远在美国，我们的服务器去查询延时相当严重，这是其二</strong>。</p>
<h2 id="05-IAP-设计上的坑"><a href="#05-IAP-设计上的坑" class="headerlink" title="05.IAP 设计上的坑"></a>05.IAP 设计上的坑</h2><p>上面讲了两个很大的坑，接下来看一看 IAP 本身有哪些坑。最大的一个就是，从 IAP 交易结果出来到通知 APP，只有一次。这里有以下几个问题：</p>
<blockquote>
<p>1. 如果用户后买成功以后，网络就不行了，那么苹果的 IAP 也收不到支付成功的通知，就没法通知 APP，我们也没法给用户发货。</p>
<p>2. 如果 IAP 通知我们支付成功，我们驱动服务器去 IAP 服务器查询失败的话，那就要等下次 APP 启动的时候，才会重新通知我们有未验证的订单。这个周期根本没法想象，如果用户一个月不重启 APP，那么我们可能一个月没法给用户发货。</p>
<p>3. 有人反馈，IAP 通知已经交易成功了，此时去沙盒里取收据数据，发现为空，或者出现通知交易成功那笔交易没有被及时的写入到沙盒数据中，导致我们服务器去 IAP 服务器查询的时候，查不到这笔订单。</p>
<p>4. 如果用户的交易还没有得到验证，就把 APP 给卸载了，以后要怎么恢复那些没有被验证的订单？</p>
<p>5. 越狱手机有无数奇葩的收据丢失或无效或被替换的问题，应该怎样酌情处理？</p>
<p>6. 交易没有发生变化，仅仅是重启一下，收据信息就会发生改变。</p>
<p>7. 当验证交易成功以后我们去取 IAP 的待验证交易列表的时候，这个列表没有数据。</p>
</blockquote>
<p>好吧，算起来有九个比较大的问题了，还有没照顾到的请各位补充。这九个问题，基本上每一个都是致命的。这么多的不确定性，我们应该怎么综合处理，怎么相互平衡？</p>
<p>我们先放一放这些问题，下一篇就一起来着手解决这些问题，现在我们先来看一看 IAP 支付的基本代码。</p>
<h2 id="06-IAP-支付代码"><a href="#06-IAP-支付代码" class="headerlink" title="06.IAP 支付代码"></a>06.IAP 支付代码</h2><p>我们先不去想那么多，先把支付逻辑跑通再说。下面我们看看 IAP 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;StoreKit/StoreKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface BLPaymentManager ()&lt;SKPaymentTransactionObserver, SKProductsRequestDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BLPaymentManager</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if(self) &#123;</span><br><span class="line">         [[SKPaymentQueue defaultQueue] addTransactionObserver:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)buyProduction &#123;</span><br><span class="line">    if ([SKPaymentQueue canMakePayments]) &#123;</span><br><span class="line"></span><br><span class="line">        [self getProductInfo:nil];</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;用户禁止应用内付费购买&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从Apple查询用户点击购买的产品的信息.</span><br><span class="line">- (void)getProductInfo:(NSString *)productIdentifier &#123;</span><br><span class="line">    NSSet *identifiers = [NSSet setWithObject:productIdentifier];</span><br><span class="line">    SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:identifiers];</span><br><span class="line">    request.delegate = self;</span><br><span class="line">    [request start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - SKPaymentTransactionObserver</span><br><span class="line"></span><br><span class="line">// 购买操作后的回调.</span><br><span class="line">- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions &#123;</span><br><span class="line">    // 这里的事务包含之前没有完成的.</span><br><span class="line">    for (SKPaymentTransaction *transcation in transactions) &#123;</span><br><span class="line">        switch (transcation.transactionState) &#123;</span><br><span class="line">            case SKPaymentTransactionStatePurchasing:</span><br><span class="line">                [self transcationPurchasing:transcation];</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SKPaymentTransactionStatePurchased:</span><br><span class="line">                [self transcationPurchased:transcation];</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SKPaymentTransactionStateFailed:</span><br><span class="line">                [self transcationFailed:transcation];</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SKPaymentTransactionStateRestored:</span><br><span class="line">                [self transcationRestored:transcation];</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SKPaymentTransactionStateDeferred:</span><br><span class="line">                [self transcationDeferred:transcation];</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - TranscationState</span><br><span class="line"></span><br><span class="line">// 交易中.</span><br><span class="line">- (void)transcationPurchasing:(SKPaymentTransaction *)transcation &#123;</span><br><span class="line">    NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];</span><br><span class="line">    NSData *receipt = [NSData dataWithContentsOfURL:receiptURL];</span><br><span class="line">    if (!receipt) &#123;</span><br><span class="line">        NSLog(@&quot;没有收据, 处理异常&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交易成功.</span><br><span class="line">- (void)transcationPurchased:(SKPaymentTransaction *)transcation &#123;</span><br><span class="line">    // 存储到本地先.</span><br><span class="line">    // 发送到服务器, 等待验证结果.</span><br><span class="line">    [[SKPaymentQueue defaultQueue] finishTransaction:transcation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交易失败.</span><br><span class="line">- (void)transcationFailed:(SKPaymentTransaction *)transcation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 已经购买过该商品.</span><br><span class="line">- (void)transcationRestored:(SKPaymentTransaction *)transcation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交易延期.</span><br><span class="line">- (void)transcationDeferred:(SKPaymentTransaction *)transcation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - SKProductsRequestDelegate</span><br><span class="line"></span><br><span class="line">// 查询成功后的回调.</span><br><span class="line">- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response &#123;</span><br><span class="line">    NSArray&lt;SKProduct *&gt; *products = response.products;</span><br><span class="line">    if (!products.count) &#123;</span><br><span class="line">        NSLog(@&quot;没有正在出售的商品&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SKPayment *payment = [SKPayment paymentWithProduct:products.firstObject];</span><br><span class="line">    [[SKPaymentQueue defaultQueue] addPayment:payment];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>代码大致做了如下事情，初始化的时候去添加支付结果的监听，并在 <code>-dealloc:</code> 方法中移除监听。同时可以通过 <code>- （void)fetchProductInfoWithProductIdentifiers:(NSSet&lt;NSString *&gt; *)productIdentifiers</code> 方法查询后台配置的商品信息。通过 <code>-buyProduction：</code> 方法购买产品，购买成功以后，IAP 通过 <code>- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions</code> 方法通知购买进度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/07/01/Article/OC 消息机制和 super 关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/01/Article/OC 消息机制和 super 关键字/" itemprop="url">OC 消息机制和 super 关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-01T12:12:42+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> 原文地址 <a href="https://juejin.im/post/5c87a218f265da2dd868cfcd" target="_blank" rel="noopener">https://juejin.im/post/5c87a218f265da2dd868cfcd</a></p>
</blockquote>
<p>原文链接 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.neroxie.com%2F2019%2F03%2F12%2FOC%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2592%258Csuper%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597%2F%23more" target="_blank" rel="noopener">OC 消息机制和 super 关键字</a></p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>在 Objective-C 里面调用一个方法<code>[object method]</code>，运行时会将它翻译成<code>objc_msgSend(id self, SEL op, ...)</code>的形式。</p>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p><code>objc_msgSend</code>的实现在<code>objc-msg-arm.s</code>、<code>objc-msg-arm64.s</code>等文件中，是通过汇编实现的。这里主要看在<code>arm64</code>即<code>objc-msg-arm64.s</code>的实现。由于汇编不熟，里面的实现只能连看带猜。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	cmp	x0, #0			// nil check and tagged pointer check</span><br><span class="line">	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</span><br><span class="line">	ldr	x13, [x0]		// x13 = isa</span><br><span class="line">	and	x16, x13, #ISA_MASK	// x16 = class	</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">LNilOrTagged:</span><br><span class="line">    /* nil check，如果为空就是调用LReturnZero，LReturnZero里调用MESSENGER_END_NIL*/</span><br><span class="line">	b.eq	LReturnZero		// nil check</span><br><span class="line"></span><br><span class="line">	// tagged</span><br><span class="line">	mov	x10, #0xf000000000000000</span><br><span class="line">	cmp	x0, x10</span><br><span class="line">	b.hs	LExtTag</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #60, #4</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line"></span><br><span class="line">LExtTag:</span><br><span class="line">	// ext tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #52, #8</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">	// x0 is already zero</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	movi	d0, #0</span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	MESSENGER_END_NIL</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面的流程可能是这样的：</p>
<p> <img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318140410.png" alt></p>
<p>从<code>CacheLookup</code>的注释有两处：</p>
<ol>
<li><code>calls imp or objc_msgSend_uncached</code></li>
<li><code>Locate the implementation for a selector in a class method cache.</code></li>
</ol>
<p>即使看不懂汇编代码，但是从上面的注释我们可以猜测，消息机制会先从缓存中去查找。</p>
<h3 id="objc-msgSend-uncached"><a href="#objc-msgSend-uncached" class="headerlink" title="__objc_msgSend_uncached"></a>__objc_msgSend_uncached</h3><p>通过方法名我们可以知道，没有缓存的时候应该会执行<code>__objc_msgSend_uncached</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">	// THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">	// Out-of-band x16 is the class to search</span><br><span class="line"></span><br><span class="line">	MethodTableLookup</span><br><span class="line">	br	x17</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgSend_uncached</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里的<code>MethodTableLookup</code>里涉及到<code>objc-runtime-new.mm</code>文件中的<code>_class_lookupMethodAndLoadCache3</code>。该函数会调用<code>lookUpImpOrForward</code>函数。</p>
<h3 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h3><p><code>lookUpImpOrForward</code>会返回一个<code>imp</code>，它的函数实现比较长，但是注释写的非常清楚。它的实现主要由以下几步（这里直接从缓存获取开始）：</p>
<ol>
<li>通过<code>cache_getImp</code>从缓存中获取方法，有则返回，否则进入第 2 步；</li>
<li>通过<code>getMethodNoSuper_nolock</code>从类的方法列表中获取，有加入缓存中并返回，否则进入第 3 步；</li>
<li>通过父类的缓存和父类的方法列表中寻找是否有对应的 imp，此时会进入一个<code>for</code>循环，沿着类的父类一直往上找，直接找到 NSObject 为止。如果找到返回，否则进入第 4 步；</li>
<li>进入方法决议（method resolve）的过程即调用<code>_class_resolveMethod</code>，如果失败，进入第 5 步；</li>
<li>在缓存、当前类、父类以及方法决议都没有找到的情况下，Objective-C 还为我们提供了最后一次翻身的机会，调用<code>_objc_msgForward_impcache</code>进行方法转发，如果找到便加入缓存；如果没有就 crash。</li>
</ol>
<p>上述过程中有几个比较重要的函数：</p>
<h4 id="class-resolveMethod"><a href="#class-resolveMethod" class="headerlink" title="_class_resolveMethod"></a><strong>_class_resolveMethod</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst) &#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        // try [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上述函数会根据当前传入的类的是不是一个元类，在<code>_class_resolveInstanceMethod</code>和<code>_class_resolveClassMethod</code>中选择一个进行调用。注释也说明了这两个方法的作用就是判断当前类是否实现了 <code>resolveInstanceMethod:</code>或者<code>resolveClassMethod:</code>方法，然后用<code>objc_msgSend</code>执行上述方法。</p>
<h4 id="class-resolveClassMethod"><a href="#class-resolveClassMethod" class="headerlink" title="_class_resolveClassMethod"></a><strong>_class_resolveClassMethod</strong></h4><p><code>_class_resolveClassMethod</code>和<code>_class_resolveInstanceMethod</code>实现类似，这里就只看<code>_class_resolveClassMethod</code>的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst) &#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123;</span><br><span class="line">         //没有找到resolveClassMethod方法，直接返回。</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    // 缓存结果</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</span><br><span class="line">    // 以下代码省略不影响阅读                          </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="objc-msgForward-impcache"><a href="#objc-msgForward-impcache" class="headerlink" title="_objc_msgForward_impcache"></a><strong>_objc_msgForward_impcache</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	MESSENGER_START</span><br><span class="line">	nop</span><br><span class="line">	MESSENGER_END_SLOW</span><br><span class="line"></span><br><span class="line">	// No stret specialization.</span><br><span class="line">	b	__objc_msgForward</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">	adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">	ldr	x17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">	br	x17</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgForward</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>_objc_msgForward_impcache</code>用来进行消息转发，但是其真正的核心是调用<code>_objc_msgForward</code>。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>关于<code>_objc_msgForward</code>在<code>objc</code>中并没有其相关实现，只能看到<code>_objc_forward_handler</code>。其实<code>_objc_msgForward</code>的实现是在<code>CFRuntime.c</code>中的，但是开源出来的<code>CFRuntime.c</code>并没有相关实现，但是也不影响我们对真理的追求。</p>
<p>我们做几个实验来验证消息转发。</p>
<h4 id="消息重定向测试"><a href="#消息重定向测试" class="headerlink" title="消息重定向测试"></a>消息重定向测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface AObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// .m文件</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">/** 验证消息重定向 */</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage)) &#123;</span><br><span class="line">         return [BObject new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .h文件</span><br><span class="line">@interface BObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation BObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage &#123;</span><br><span class="line">    NSLog(@&quot;%@ send message&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AObject *a = [AObject new];</span><br><span class="line">[a sendMessage];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-03-12 10:18:54.252949+0800 iOSCodeLearning[18165:5967575] BObject send message</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在<code>forwardingTargetForSelector:</code>处打个断点，查看一下调用栈：</p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318140550.png" alt></p>
<p><code>_CF_forwarding_prep_0</code>和<code>___forwarding___</code>这两个方法会先被调用了，之后调用了<code>forwardingTargetForSelector:</code>。</p>
<h4 id="方法签名测试"><a href="#方法签名测试" class="headerlink" title="方法签名测试"></a>方法签名测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface AObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// .m文件</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">/** 消息重定向 */</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">   return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 方法签名测试 */</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage)) &#123;</span><br><span class="line">        return [BObject instanceMethodSignatureForSelector:@selector(sendMessage)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL selector = [anInvocation selector];</span><br><span class="line">    if (selector == @selector(sendMessage)) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:[BObject new]];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .h文件</span><br><span class="line">@interface BObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation BObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage &#123;</span><br><span class="line">    NSLog(@&quot;%@ send message&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AObject *a = [AObject new];</span><br><span class="line">[a sendMessage];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318140550.png" alt></p>
<p>代码执行结果和消息重定向测试的运行结果一致。<code>_CF_forwarding_prep_0</code>和<code>___forwarding___</code>这两个方法又再次被调用了，之后代码会先执行<code>forwardingTargetForSelector:</code>（消息重定向），消息重定向如果失败后调用<code>methodSignatureForSelector:</code>和<code>forwardInvocation:</code>方法签名。所以说<code>___forwarding___</code>方法才是消息转发的真正实现。</p>
<h4 id="crash-测试"><a href="#crash-测试" class="headerlink" title="crash 测试"></a>crash 测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface AObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// .m文件</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 验证Crash */</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage)) &#123;</span><br><span class="line">        NSLog(@&quot;%@ doesNotRecognizeSelector&quot;, self.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .h文件</span><br><span class="line">@interface BObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation BObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage &#123;</span><br><span class="line">    NSLog(@&quot;%@ send message&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AObject *a = [AObject new];</span><br><span class="line">[a sendMessage];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>代码运行结果肯定是 crash，结合上面的代码我们知道消息转发会调用<code>___forwarding___</code>这个内部方法。<code>___forwarding___</code>方法调用顺序是<code>forwardingTargetForSelector:</code>-&gt;<code>methodSignatureForSelector:</code>-&gt;<code>doesNotRecognizeSelector:</code></p>
<p>我们用一张图表示整个消息发送的过程：</p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318140632.png" alt></p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>我们先查看一下执行<code>[super init]</code>的时候，调用了那些方法</p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190318140712.png" alt></p>
<p><code>objc_msgSendSuper2</code>的声明在<code>objc-abi.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// objc_msgSendSuper2() takes the current search class, not its superclass.</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><code>objc_super</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">    /// Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    /// Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    /* For compatibility with old objc-runtime.h header */</span><br><span class="line">    __unsafe_unretained _Nonnull Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    /* super_class is the first class to search */</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>从上面的定义我们可以知道<code>receiver</code>即消息的实际接收者， <code>super_class</code>为指向当前类的父类。</p>
<p>所以该函数实际的操作是：从<code>objc_super</code>结构体指向的<code>super_class</code>开始查找，直到会找到 NSObject 的方法为止。找到后以<code>receiver</code>去调用。当然整个查找的过程还是和消息发送的流程一样。</p>
<p>所以我们能理解为什么下面这段代码执行的结果都是<code>AObject</code>了吧。虽然使用<code>[super class]</code>，但是真正执行方法的对象还是<code>AObject</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 代码</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [super class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self class]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">2019-03-12 19:44:46.003313+0800 iOSCodeLearning[34431:7234182] AObject</span><br><span class="line">2019-03-12 19:44:46.003442+0800 iOSCodeLearning[34431:7234182] AObject</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/06/23/Article/Objective-C Runtime 机制简析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/23/Article/Objective-C Runtime 机制简析/" itemprop="url">Objective-C Runtime 机制简析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-23T12:12:42+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Objective-C 在 C 的基础上添加了面向对象的特性，同时它是一种动态编程语言，将静态语言在编译和链接时需要做的一些事情给延后到运行时执行。例如方法的调用，只有在程序执行的时候，才能具体定位到哪个类的哪个方法。这就需要一个运行时库，就是 Runtime。</p>
<h1 id="1-类的结构和定义"><a href="#1-类的结构和定义" class="headerlink" title="1. 类的结构和定义"></a>1. 类的结构和定义</h1><p>在 Objective-C 中，类实际上是一个 objc_class 结构体，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">   Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">   Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">   const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">   long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">   long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">   long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">   struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">   struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">   struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">   struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">   Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，在 objc2.0 中，除了 isa 指针外，objc_class 的其他成员变量皆已被弃用。<br>其中 isa 是 objc_class 结构体的指针，它指向当前类的 meta class。</p>
<ul>
<li><strong>meta class 与 class</strong><br>在 objc 中，class 存储类的实例方法（-），meta class 存储类的类方法（+），class 的 isa 指针指向 meta class。下文会对此详细介绍。</li>
</ul>
<p>objc_object 结构体就是 objc 中的对象，它仅包含一个 isa 指针，指向当前对象所属的类。 我们常用的 id 实质上就是一个 objc_object 类型的指针。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023919.jpg" alt></p>
<p>如图 1.1 所示，一个对象（Instance of Subclass）的 isa 指针指向它所属的类 Subclass（class），Subclass（class）的 isa 指针指向 Subclass（meta），Subclass（meta）的 isa 指针指向 Root class（meta）。Root class（meta）的 isa 指针指向本身。<br>同时，Root class（meta）的父类是 Root class（class），即 NSObject，NSObject 的父类为 nil。</p>
<h1 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2. 方法的调用"></a>2. 方法的调用</h1><p>在这里需要先了解几个概念<br><strong>SEL</strong><br>SEL 是 objc_selector 类型指针，是根据特定规则生成的方法的唯一标识。需要注意的是，只要方法名相同，生成的 SEL 就相同，与这个方法属于哪个类没有关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p><strong>IMP</strong><br>如果说，SEL 是方法名，那么 IMP 就是方法的实现。IMP 指针定义了一个方法的入口，指向了实现方法的代码块的内存地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure>
<p><strong>objc_method</strong><br>在 objc 中，方法实质上是一个 objc_method 指针。其中，method_name 相当于 objc_method 的 hash 值，runtime 通过 method_name 找到相应的方法入口（method_imp），从而执行方法的代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p><strong>调用一个方法时具体做了什么？</strong><br>在 Objective-C 中，方法的调用采用如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object methodWithArg:arg];</span><br></pre></td></tr></table></figure>
<p>在编译期间，以上代码会被转化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend（object, methodWithArg, arg）</span><br></pre></td></tr></table></figure>
<p>可以把它看作是发送消息的过，其中 object 为消息的接收体，它可能是一个对象，也可能是一个类。若为对象，则是实例方法（- 方法）；反之，则是类方法（+ 方法）。mehodWithArg、arg 是具体的消息内容。<br>object 接收到消息之后，若是实例方法，则会从其所属的类 Subclass(class) 的 methodLists 去寻找 methodWithArg: 方法。若未找着，则到其父类 Superclass(class) 的 methodLists 中寻找。以此类推，直到根类 NSObject，若仍未找着，就 crash。<br>同理，若是类方法，则从对象所属类的 meta class 开始寻找。</p>
<h1 id="3-在-Objective-C-2-0-中的变化"><a href="#3-在-Objective-C-2-0-中的变化" class="headerlink" title="3. 在 Objective-C 2.0 中的变化"></a>3. 在 Objective-C 2.0 中的变化</h1><p>前面提到过在 objc2.0 中，objc_class 只剩下一个 isa 指针。由于 Xcode 对 API 进行了一定的封装，类的信息并未全部对开发者开放。我们不妨通过阅读 Objective-C 2.0 的源码去分析，可以通过 <a href="https://link.jianshu.com?t=https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">官网</a>浏览，或者从 <a href="https://link.jianshu.com?t=https://github.com/opensource-apple/objc4" target="_blank" rel="noopener">github</a> 上下载源码。<br>从 objc-runtime-new.h 中可以看到 objc_class 的定义（只截取关键代码，下文同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;;</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，superclass 指向父类，cache 缓存指针、方法入口等，用于提高效率。bits 用于存储类名、类版本号、方法列表、协议列表等信息，替代了 Objective-C1.0 中 methodLists、protocols 等成员变量。</p>
<p><strong>class_data_bits_t 结构体</strong><br>class_data_bits_t 结构体中只有一个 64 位的指针 bits，它相当于 class_rw_t 指针加上 rr/alloc 等标志位。其中 class_rw_t 指针存在于 4~47 位（从 1 开始计）。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023930.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define FAST_IS_SWIFT         (1UL&lt;&lt;0)</span><br><span class="line">#define FAST_DATA_MASK        0x00007ffffffffff8UL</span><br></pre></td></tr></table></figure>
<p>is_swift 标记位标示是否为 swift 的类。通过进行位运算可以得到一个 class_rw_t 类型指针。<br>class_rw_t 结构体的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>其中 methods 存储方法列表、properties 存储属性列表、protocols 存储协议列表。注意到这里有一个 class_ro_t 类型指针，我们会在下文详细介绍。</p>
<p><strong>dyld 加载镜像</strong><br>dyld 是 objc 的动态链接库，在程序运行时，会将镜像加载进内存。</p>
<ul>
<li><strong>镜像</strong><br>工程的编译产物，包括一些动态链接库、Foundation 等等，是一些二进制文件。</li>
</ul>
<p>在程序初始化方法_objc_init 中注册了两个回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dyld_register_image_state_change_handler(dyld_image_state_bound,1/*batch*/, &amp;map_2_images);</span><br><span class="line">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</span><br></pre></td></tr></table></figure>
<p>其中, map_2_images 方法的注释为：Process the given images which are being mapped in by dyld，即处理由 dyld 映射的给定镜像。它的调用如下：<br>_map_2_images → map_images_nolock → _read_images → realizeAllClasses_<br>realizeAllClasses 会完成对镜像中所有类的加载和预处理，它最终会调用 realizeClass 来处理每一个类，而 realizeClass 又通过调用 methodizeClass 来对类结构体的 methods 列表赋值。<br>可以通过添加符号断点，来直观的查看这几个方法的调用关系，如图 3.2。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023942.png" alt></p>
<p><strong>+load 方法</strong><br>+load 方法会在 main 方法之前被调用，所有使用到的类的 load 方法都会被调用。先调用父类的 + load 方法，再调用子类的 + load 方法；先调用主类的 + load 方法，再调用分类的 + load 方法。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023946.png" alt></p>
<p>图 3.3 是 + load 方法的调用栈。load_images 方法是每个镜像加载完毕的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const char *</span><br><span class="line">load_images(enum dyld_image_states state, uint32_t infoCount,</span><br><span class="line">            const struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    bool found;</span><br><span class="line"></span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    found = false;</span><br><span class="line">    for (uint32_t i = 0; i &lt; infoCount; i++) &#123;</span><br><span class="line">        if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!found) return nil;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    if (found) &#123;</span><br><span class="line">        call_load_methods();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load_Images 会判断镜像是否实现了 + load 方法，并且调用 load_images_nolock 方法找到所有 + load 方法，之后通过 call_load_methods 调用所有的 + load 方法。</p>
<p><strong>class_ro_t</strong><br>class_ro_t 与 class_rw_t 的最大区别在于一个是只读的，一个是可读写的，实质上 ro 就是 readonly 的简写，rw 是 readwrite 的简写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在编译之后，class_ro_t 的 baseMethodList 就已经确定。当镜像加载的时候，methodizeClass 方法会将 baseMethodList 添加到 class_rw_t 的 methods 列表中，之后会遍历 category_list，并将 category 的方法也添加到 methods 列表中。<br>这里的 category 指的是分类，基于此，category 能扩充一个类的方法。这是开发时经常需要使用到。<br>class_ro_t 在内存中是不可变的。在运行期间，动态给类添加方法，实质上是更新 class_rw_t 的 methods 列表。<br>baseProtocols 与 baseMethodList 类似。<br>objc_object、objc_class、class_rw_t、class_ro_t 的关系如图 3.4。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-19-023952.png" alt></p>
<p><strong>类的理解与方法的调用</strong></p>
<ul>
<li><p>对象方法：前面提过，调用对象方法，相当于给对象发送消息, 例如 [obj methodWithArg: arg] 。 当 obj_object 接收到消息后，通过其 isa 指针找到对应的 objc_class，objc_class 又通过其 data() 方法，查询 class_rw_t 的 methods 列表。若有，则返回；否则，到其父类寻找。以此类推，直到根类，若在根类中仍没有该方法，则 crash。</p>
</li>
<li><p>类方法： 在 objc 中，类本身也是一个对象。objc_class 继承自 objc_object，有一个 isa 指针，指向其所属的类，即 meta class。可以这样理解，类是 meta class 的对象。所以，当调用类方法是，例如 [classObj methodWithArg: arg]，classObj 也会通过其 isa 指针到其所属的类（meta class）中寻找。这也就是为什么说，图 1.1 里 class 存储对象方法，meta class 存储类方法。</p>
</li>
<li><p>meta class 的 isa 指针：meta class 本身也是一个对象，它的 isa 指针指向的也是其所属的类。子 meta class 的 isa 指针指向 NSObjct 的 meta class。 NSObjct 的 meta class 的 isa 指针指向自身。当然，由于苹果进行了封装，在开发中基本不可能直接去使用 meta class。</p>
</li>
</ul>
<p><strong>对象的成员变量寻址</strong><br>前面提过，在 objc_object 中只有一个 isa 指针。实际上当我们调用 +alloc 方法来初始化一个对象时，也仅仅在内存中生成了一个 objc_object 结构体，并根据其 instanceSize 来分配空间，将其 isa 指针指向所属的类。<br>类的成员变量 ivar_t 存储在 class_ro_t 中的 ivar_list_t * ivars 中，ivar_t 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *type;</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 offset 是成员变量相对于对象内存地址的偏移量，正是通过它来完成变量寻址。<br>当我们使用对象的成员变量时，如 myObject.var ，编译器会将其转化为 object_getInstanceVariable(myObject, ‘var’, **value) 找到其 ivar_t 结构体 ivar，然后调用 object_getIvar(myObject, ivar) 来获取成员变量的内存地址。其计算公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id *location = (id *)((char *)obj + ivar_offset);</span><br></pre></td></tr></table></figure>
<p>基于此，虽然多个对象的 isa 指针指向同一个 objc_class，但由于对象的内存地址不一样，所以它们的实例变量存储位置也不一样，从而实现对象与类之间的多对一关系。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/06/19/Article/面试驱动技术 - Category 相关考点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/19/Article/面试驱动技术 - Category 相关考点/" itemprop="url">面试驱动技术 - Category 相关考点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-19T12:12:42+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Category 相关的问题一般初中级问的比较多，一般最深的就问到关联对象，本文把比较常见的 Category 的问题都罗列解决了一下，如果还有其他常见的 Category 的试题欢迎补充~</em></p>
<h2 id="I-Category"><a href="#I-Category" class="headerlink" title="I. Category"></a>I. Category</h2><h3 id="Category-相关面试题"><a href="#Category-相关面试题" class="headerlink" title="Category 相关面试题"></a>Category 相关面试题</h3><ul>
<li>Category 实现原理？</li>
<li>实际开发中，你用 Category 做了哪些事？</li>
<li>Category 能否添加成员变量，如果可以，如何添加？</li>
<li>load 、initialize 方法的区别是什么，他们在 category 中的调用顺序？以及出现继承时他们之间的调用过程？</li>
<li>Category 和 Class Extension 的区别是什么？</li>
<li>为什么分类会 “覆盖” 宿主类的方法？</li>
</ul>
<h4 id="1-Category-的特点"><a href="#1-Category-的特点" class="headerlink" title="1.Category 的特点"></a>1.Category 的特点</h4><ul>
<li>运行时决议<ul>
<li>通过 <code>runtime</code> 动态将分类的方法合并到类对象、元类对象中</li>
<li>实例方法合并到类对象中，类方法合并到元类对象中</li>
</ul>
</li>
<li>可以为系统类添加分类</li>
</ul>
<h4 id="2-分类中可以添加哪些内容"><a href="#2-分类中可以添加哪些内容" class="headerlink" title="2. 分类中可以添加哪些内容"></a>2. 分类中可以添加哪些内容</h4><ul>
<li>实例方法</li>
<li>类方法</li>
<li>协议</li>
<li>属性</li>
</ul>
<h3 id="分类中原理解析"><a href="#分类中原理解析" class="headerlink" title="分类中原理解析"></a>分类中原理解析</h3><p>使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc MNPerson+Test.m</code> 函数，生产一个 cpp 文件, 窥探其底层结构 (编译状态)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">    //宿主类名称 - 这里的MNPerson</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    //宿主类对象,里面有isa</span><br><span class="line">    struct _class_t *cls;</span><br><span class="line"></span><br><span class="line">    //实例方法列表</span><br><span class="line">    const struct _method_list_t *instance_methods;</span><br><span class="line"></span><br><span class="line">    //类方法列表</span><br><span class="line">    const struct _method_list_t *class_methods;</span><br><span class="line"></span><br><span class="line">    //协议列表</span><br><span class="line">    const struct _protocol_list_t *protocols;</span><br><span class="line"></span><br><span class="line">    //属性列表</span><br><span class="line">    const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//_class_t 结构</span><br><span class="line">struct _class_t &#123;</span><br><span class="line">	struct _class_t *isa;</span><br><span class="line">	struct _class_t *superclass;</span><br><span class="line">	void *cache;</span><br><span class="line">	void *vtable;</span><br><span class="line">	struct _class_ro_t *ro;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>每个分类都是独立的</li>
<li>每个分类的结构都一致，都是<code>category_t</code></li>
</ul>
<h4 id="函数转换"><a href="#函数转换" class="headerlink" title="函数转换"></a>函数转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation MNPerson (Test)</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;test - rua~&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-040902.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line"></span><br><span class="line">    /* 二维数组( **mlists =&gt; 两颗星星，一个)</span><br><span class="line">     [</span><br><span class="line">        [method_t,],</span><br><span class="line">        [method_t,method_t],</span><br><span class="line">        [method_t,method_t,method_t],</span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;//宿主类，分类的总数</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;//倒序遍历，最先访问最后编译的分类</span><br><span class="line"></span><br><span class="line">        // 获取某一个分类</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        // 分类的方法列表</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            //最后编译的分类，最先添加到分类数组中</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line"></span><br><span class="line">    // 核心：将所有分类的对象方法，附加到类对象的方法列表中</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">    if (hasArray()) &#123;</span><br><span class="line">        // many lists -&gt; many lists</span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line"></span><br><span class="line">        //realloc - 重新分配内存 - 扩容了</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">        //memmove,内存挪动</span><br><span class="line">        //array()-&gt;lists 原来的方法列表</span><br><span class="line">        memmove(array()-&gt;lists + addedCount,</span><br><span class="line">                array()-&gt;lists,</span><br><span class="line">                oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line"></span><br><span class="line">        //memcpy - 将分类的方法列表 copy 到原来的方法列表中</span><br><span class="line">        memcpy(array()-&gt;lists,</span><br><span class="line">               addedLists,</span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>画图分析就是</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-041106.jpg" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-041125.jpg" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-042435.jpg" alt></p>
<p><img src="https://sylarimage.oss-cn-shenzhen.aliyuncs.com/20190314121618.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-042114.jpg" alt></p>
<h4 id="3-实际开发中，你用-Category-做了哪些事？"><a href="#3-实际开发中，你用-Category-做了哪些事？" class="headerlink" title="3. 实际开发中，你用 Category 做了哪些事？"></a>3. 实际开发中，你用 Category 做了哪些事？</h4><ul>
<li><p>声明私有方法</p>
</li>
<li><p>分解体积庞大的类文件</p>
</li>
<li><p>把<code>Framework</code>的私有方法公开</p>
</li>
</ul>
<h4 id="4-Category-实现原理？"><a href="#4-Category-实现原理？" class="headerlink" title="4.Category 实现原理？"></a>4.Category 实现原理？</h4><ul>
<li>Category 编译之后，底层结构是 category_t，里面存储着分类的各种信息，包括 对象方法、类方法、属性、协议信息</li>
<li>分类的在编译后，方法并不会直接添加到类信息中，而是要在程序运行的时候，通过 <code>runtime</code>, 讲 Category 的数据，</li>
</ul>
<h4 id="5-为什么分类会-“覆盖”-宿主类的方法？"><a href="#5-为什么分类会-“覆盖”-宿主类的方法？" class="headerlink" title="5. 为什么分类会 “覆盖” 宿主类的方法？"></a>5. 为什么分类会 “覆盖” 宿主类的方法？</h4><ul>
<li>其实不是真正的 “覆盖”，宿主类的同名方法还是存在</li>
<li>分类将附加到类对象的方法列表中，整合的时候，分类的方法优先放到前面</li>
<li>OC 的函数调用底层走的是 msg_send() 函数，它做的是方法查找，因为分类的方法优先放在前面，所以通过选择器查找到分类的方法之后直接调用，宿主类的方法看上去就像被 “覆盖” 而没有生效</li>
</ul>
<h4 id="6-Category-和-Class-Extension-的区别是什么？"><a href="#6-Category-和-Class-Extension-的区别是什么？" class="headerlink" title="6.Category 和 Class Extension 的区别是什么？"></a>6.Category 和 Class Extension 的区别是什么？</h4><h4 id="Class-Extension-扩展"><a href="#Class-Extension-扩展" class="headerlink" title="Class Extension(扩展)"></a><em>Class Extension(扩展)</em></h4><ul>
<li>声明私有属性</li>
<li>声明私有方法</li>
<li>声明私有成员变量</li>
<li>编译时决议，Category 运行时决议</li>
<li>不能为系统类添加扩展</li>
<li>只能以声明的形式存在，多数情况下，寄生于宿主类的. m 文件中</li>
</ul>
<h2 id="II-load-、initialize"><a href="#II-load-、initialize" class="headerlink" title="II. load 、initialize"></a>II. load 、initialize</h2><h3 id="load-实现原理"><a href="#load-实现原理" class="headerlink" title="load 实现原理"></a>load 实现原理</h3><blockquote>
<ul>
<li>类第一次加载进内存的时候，会调用 <code>+ load</code> 方法，无需导入，无需使用</li>
<li>每个类、分类的 <code>+ load</code> 在程序运行过程中只会执行一次</li>
<li><code>+ load</code> 走的不是消息发送的 <code>objc_msgSend</code> 调用，而是找到 <code>+ load</code> 函数的地址，直接调用</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1\. Repeatedly call class +loads until there aren’t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            //先加载宿主类的load方法(按照编译顺序，调用load方法)</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2\. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3\. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    // 递归调用，先将父类添加到load方法列表中，再将自己加进去</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h4><ol>
<li>先调用宿主类的<code>+ load</code> 函数<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的 + load 之前会先调用父类的 + load</li>
</ul>
</li>
<li>再调用分类的的<code>+ load</code> 函数<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
</li>
</ol>
<p>实验证明：宿主类先调用，分类再调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-02-27 17:28:00.519862+0800 load-Initialize-Demo[91107:2281575] MNPerson + load</span><br><span class="line">2019-02-27 17:28:00.520032+0800 load-Initialize-Demo[91107:2281575] MNPerson (Play) + load</span><br><span class="line">2019-02-27 17:28:00.520047+0800 load-Initialize-Demo[91107:2281575] MNPerson (Eat) + load</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-13-142313.png" alt="image-20190313220920309"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-02-27 17:39:10.354050+0800 load-Initialize-Demo[91308:2303030] MNDog + load (宿主类1)</span><br><span class="line">2019-02-27 17:39:10.354237+0800 load-Initialize-Demo[91308:2303030] MNPerson + load (宿主类2)</span><br><span class="line">2019-02-27 17:39:10.354252+0800 load-Initialize-Demo[91308:2303030] MNDog (Rua) + load (分类1)</span><br><span class="line">2019-02-27 17:39:10.354263+0800 load-Initialize-Demo[91308:2303030] MNPerson (Play) + load(分类2)</span><br><span class="line">2019-02-27 17:39:10.354274+0800 load-Initialize-Demo[91308:2303030] MNPerson (Eat) + load(分类3)</span><br><span class="line">2019-02-27 17:39:10.354285+0800 load-Initialize-Demo[91308:2303030] MNDog (Run) + load(分类4)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="Initialize-实现原理"><a href="#Initialize-实现原理" class="headerlink" title="Initialize 实现原理"></a>Initialize 实现原理</h4><blockquote>
<ul>
<li>类第一次接收到消息的时候，会调用该方法，需导入，并使用</li>
<li><code>+ Initialize</code> 走的是消息发送的 <code>objc_msgSend</code> 调用</li>
</ul>
</blockquote>
<h4 id="Initialize-题目出现"><a href="#Initialize-题目出现" class="headerlink" title="Initialize 题目出现"></a>Initialize 题目出现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*父类*/</span><br><span class="line">@interface MNPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNPerson</span><br><span class="line"></span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;MNPerson + initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/*子类1*/</span><br><span class="line">@interface MNTeacher : MNPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNTeacher</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/*子类2*/</span><br><span class="line">@interface MNStudent : MNPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNStudent</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">问题出现:以下会输出什么结果</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        [MNTeacher alloc];</span><br><span class="line">        [MNStudent alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-02-27 17:57:33.305655+0800 load-Initialize-Demo[91661:2331296] MNPerson + initialize</span><br><span class="line">2019-02-27 17:57:33.305950+0800 load-Initialize-Demo[91661:2331296] MNPerson + initialize</span><br><span class="line">2019-02-27 17:57:33.306476+0800 load-Initialize-Demo[91661:2331296] MNPerson + initialize</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>exo me? 为啥打印三次呢</strong></p>
<p>原理分析：</p>
<ol>
<li><code>initialize</code> 在类第一次接收消息的时候会调用，OC 里面的 <code>[ xxx ]</code> 调用都可以看成 <code>objc_msgSend</code>, 所以这时候，<code>[MNTeacher alloc]</code> 其实内部会调用 <code>[MNTeacher initialize]</code></li>
<li><code>initialize</code> 调用的时候，要先实现自己父类的 <code>initialize</code> 方法，第一次调用的时候，<code>MNPerson</code> 没被使用过，所以未被初始化，要先调用一下父类的 <code>[MNPerson initialize]</code>, 输出第一个<code>MNPerson + initialize</code></li>
<li><code>MNPerson</code> 调用了 <code>initialize</code> 之后，轮到<code>MNTeacher</code> 类自己了，由于他内部没有实现 <code>initialize</code>方法，所以调用父类的<code>initialize</code>, 输出第二个<code>MNPerson + initialize</code></li>
<li>然后轮到<code>[MNStudent alloc]</code>，内部也是调用 <code>[MNStudent initialize]</code>, 然后判断得知 父类<code>MNPerson</code>类调用过<code>initialize</code>了，因此调用自身的就够了，由于他和<code>MNTeacher</code> 一样，也没实现<code>initialize</code> 方法，所以同理调用父类的<code>[MNPerson initialize]</code>, 输出第 3 个<code>MNPerson + initialize</code></li>
</ol>
<hr>
<h3 id="initialize-与-load-的区别"><a href="#initialize-与-load-的区别" class="headerlink" title="initialize 与 load 的区别"></a>initialize 与 load 的区别</h3><ul>
<li>load 是类第一次加载的时候调用，initialize 是类第一次接收到消息的时候调用，每个类只会 initialize 一次（父类的 initialize 方法可能被调用多次）</li>
<li>load 和 initialize，加载 or 调用的时候，都会先调用父类对应的 <code>load</code> or <code>initialize</code> 方法，再调用自己本身的;</li>
<li>load 和 initialize 都是系统自动调用的话，都只会调用一次</li>
<li>调用方式也不一样，load 是根据函数地址直接调用，initialize 是通过<code>objc_msgSend</code></li>
<li>调用时刻，load 是 runtime 加载类、分类的时候调用（只会调用一次）</li>
<li>调用顺序:<ul>
<li>load:<ul>
<li>先调用类的 load<ul>
<li>先编译的类，优先调用 load</li>
<li>调用子类的 load 之前，会先调用父类的 load</li>
</ul>
</li>
<li>在调用分类的 load</li>
</ul>
</li>
<li>initialize：<ul>
<li>先初始化父列</li>
<li>再初始化子类（可能最终调用的是父类的初始化方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/*父类*/</span><br><span class="line">@interface MNPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNPerson</span><br><span class="line"></span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;MNPerson + initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;MNPerson + load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*子类1*/</span><br><span class="line">@interface MNTeacher : MNPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNTeacher</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;MNTeacher + load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*子类2*/</span><br><span class="line">@interface MNStudent : MNPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNStudent</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;MNStudent + load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">问题出现:以下会输出什么结果?</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        [MNTeacher load];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="答案出现！！！"><a href="#答案出现！！！" class="headerlink" title="答案出现！！！"></a>答案出现！！！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-02-27 18:17:12.034392+0800 load-Initialize-Demo[92064:2370496] MNPerson + load</span><br><span class="line">2019-02-27 18:17:12.034555+0800 load-Initialize-Demo[92064:2370496] MNStudent + load</span><br><span class="line">2019-02-27 18:17:12.034569+0800 load-Initialize-Demo[92064:2370496] MNTeacher + load</span><br><span class="line">2019-02-27 18:17:12.034627+0800 load-Initialize-Demo[92064:2370496] MNPerson + initialize</span><br><span class="line">2019-02-27 18:17:12.034645+0800 load-Initialize-Demo[92064:2370496] MNPerson + initialize</span><br><span class="line">2019-02-27 18:17:12.034658+0800 load-Initialize-Demo[92064:2370496] MNTeacher + load</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>exo me again！怎么这么多！连 load 也有了？</p>
<p>解释：</p>
<ol>
<li>前三个 load 不多 bb 了吧，程序一运行，runtime 直接将全部的类加载到内存中，肯定最先输出；</li>
<li>第一个 <code>MNPerson + initialize</code>，因为是<code>MNTeacher</code>的调用，所以会先让父类<code>MNPerson</code> 调用一次<code>initialize</code>，输出第一个 <code>MNPerson + initialize</code></li>
<li>第二个 <code>MNPerson + initialize</code>, <code>MNTeacher</code> 自身调用，由于他自己没有实现 <code>initialize</code>, 调用父类的<code>initialize</code>， 输出第二个 <code>MNPerson + initialize</code></li>
<li>最后一个<code>MNTeacher + load</code>可能其实有点奇怪，不是说 <code>load</code>只会加载一次吗，而且他还不走 <code>objc_msgSend</code> 吗，怎么还能调用这个方法？<ul>
<li>因为！当类第一次加载进内存的时候，调用的 <code>load</code> 方法是系统调的，这时候不走 <code>objc_msgSend</code></li>
<li>但是，你现在是<code>[MNTeacher load]</code>啊，这个就是 objc_msgSend(MNTeacher,@selector(MNTeacher))，这就跑到<code>MNTeacher + load</code>里了！</li>
<li>只是一般没人手动调用<code>load</code> 函数，但是，还是可以调用的！</li>
</ul>
</li>
</ol>
<h2 id="III-关联对象-AssociatedObject"><a href="#III-关联对象-AssociatedObject" class="headerlink" title="III. 关联对象 AssociatedObject"></a>III. 关联对象 AssociatedObject</h2><h3 id="Category-能否添加成员变量，如果可以，如何添加？"><a href="#Category-能否添加成员变量，如果可以，如何添加？" class="headerlink" title="Category 能否添加成员变量，如果可以，如何添加？"></a>Category 能否添加成员变量，如果可以，如何添加？</h3><blockquote>
<p>这道题实际上考的就是关联对象</p>
</blockquote>
<p>如果是普通类声明生命属性的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface MNPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy)NSString *property;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上述代码系统内部会自动三件事：</p>
<ol>
<li>帮我们生成一个生成变量_property</li>
<li>生成一个 <code>get</code> 方法 <code>- (NSString *)property</code></li>
<li>生成一个 <code>set</code> 方法 <code>- (void)setProperty:(NSString *)property</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation MNPerson&#123;</span><br><span class="line">    NSString *_property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setProperty:(NSString *)property&#123;</span><br><span class="line">    _property = property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)property&#123;</span><br><span class="line">    return _property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>分类也是可以添加属性的 - 类结构里面，有个<code>properties</code> 列表，里面就是 存放属性的;</p>
<p>分类里面，生成属性，只会生成方法的声明，不会生成成员变量 &amp;&amp; 方法实现！</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-13-142324.png" alt="image-20190313221010091"></p>
<blockquote>
<p>人工智障翻译：实例变量不能放在分类中</p>
</blockquote>
<p>所以：</p>
<p><strong>不能直接给 category 添加成员变量，但是可以间接实现分类有成员变量的效果 (效果上感觉像成员变量)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface MNPerson (Test)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MNPerson (Test)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-13-142331.png" alt="image-20190313221032988"></p>
<p><code>person.age = 10</code>等价于 <code>[person setAge:10]</code>，所以证明了，给分类声明属性之后，并没有添加其对应的实现！</p>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>objc_setAssociatedObject Api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(    &lt;#id  _Nonnull object#&gt;, (对象)</span><br><span class="line">                             &lt;#const void * _Nonnull key#&gt;,(key)</span><br><span class="line">                             &lt;#id  _Nullable value#&gt;,(关联的值)</span><br><span class="line">                             &lt;#objc_AssociationPolicy policy#&gt;)(关联策略)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>关联策略，等价于属性声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,          </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, </span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,  </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,      </span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403         </span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-14-042550.jpg" alt></p>
<p>比如这里的 age 属性，默认声明是<code>@property (nonatomic, assign) NSInteger age;</code>，就是 assign，所以这里选择<code>OBJC_ASSOCIATION_ASSIGN</code></p>
<p>取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_getAssociatedObject(&lt;#id  _Nonnull object#&gt;, &lt;#const void * _Nonnull key#&gt;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="面试题-以下代码输出的结果是啥"><a href="#面试题-以下代码输出的结果是啥" class="headerlink" title="面试题 - 以下代码输出的结果是啥"></a>面试题 - 以下代码输出的结果是啥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        MNPerson *person = [[MNPerson alloc]init];</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            MNPerson *test = [[MNPerson alloc]init];</span><br><span class="line">            objc_setAssociatedObject(person,</span><br><span class="line">                                     @&quot;test&quot;,</span><br><span class="line">                                     test,</span><br><span class="line">                                     OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%@&quot;,objc_getAssociatedObject(person, @&quot;test&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-13-142345.png" alt="image-20190313221130229"></p>
<blockquote>
<p>原因，关联的对象是 person，关联的 value 是 test，test 变量 出了他们的<code>{}</code> 作用域之后，就会销毁; 此时通过 key 找到 对应的对象，访问对象内部的 value，因为 test 变量已经销毁了，所以程序崩溃了，这也说明了 =&gt; <strong>内部 test 对 value 是强引用！</strong></p>
</blockquote>
<h3 id="关联对象的本质"><a href="#关联对象的本质" class="headerlink" title="关联对象的本质"></a>关联对象的本质</h3><blockquote>
<p>在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量），所以我们需要使用关联对象以及两个方法来模拟构成属性的三个要素。</p>
</blockquote>
<p>引用自 <a href="https://link.juejin.im?target=https%3A%2F%2Fdraveness.me%2Fao" target="_blank" rel="noopener">关联对象 AssociatedObject 完全解析</a></p>
<hr>
<h3 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h3><p>实现关联对象技术的核心对象有</p>
<ul>
<li>AssociationsManager</li>
<li>AssociationsHashMap</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static spinlock_t _lock;//自旋锁，保证线程安全</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap&gt; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>以关联对象代码为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  objc_setAssociatedObject(obj, @selector(key), @&quot;hello world&quot;, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-13-142352.jpg" alt="image-20190313221149179"></p>
<ul>
<li>关联对象并不是存储在被关联对象本身的内存中的</li>
<li>关联对象，存储在全局的一个统一的<code>AssociationsManager</code>中</li>
<li>关联对象其实就是 <code>ObjcAssociation</code> 对象, 关联的 <code>value</code> 就放在 <code>ObjcAssociation</code> 内</li>
<li>关联对象由 <code>AssociationsManager</code> 管理并在 <code>AssociationsHashMap</code> 存储</li>
<li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li>
<li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li>
<li>每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li>
<li>存储在全局的一个统一的<code>AssociationsManager</code> 内部有一持有一个<code>_lock</code>，他其实是一个 spinlock_t(自旋锁), 用来保证<code>AssociationsHashMap</code>操作的时候，是线程安全的</li>
</ul>
<p><code>Category</code> 相关的问题一般初中级问的比较多，一般最深的就问到<code>关联对象</code>，上面的问题以及解答已经把比较常见的 <code>Category</code> 的问题都罗列解决了一下，如果还有其他常见的 <code>Category</code> 的试题欢迎补充~</p>
<hr>
<p>参考资料:</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fdraveness.me%2Fao" target="_blank" rel="noopener">关联对象 AssociatedObject 完全解析</a></p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fnshipster.com%2Fassociated-objects%2F" target="_blank" rel="noopener">associated-objects</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/06/16/JSON解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/16/JSON解析/" itemprop="url">Json 解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-16T12:12:42+08:00">
                2017-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>使用NSJSONSerialization，我们可以将JSON转换为AnyObject对象，或将AnyObject对象转换为JSON对象。</p>
<p>将一个AnyObject对象转换JSON对象必须具备以下条件。</p>
<ol>
<li>该对象的是NSArray或NSDictionary。</li>
<li>内部数据只能是NSString, NSNumber, NSArray, NSDictionary, 或NSNull。</li>
<li>所有字典的key是NSString。</li>
<li>Number类型数据不能是NaN或无穷。</li>
</ol>
<p>你还可以通过方法<code>isValidJSONObject:</code>判断一个对象能否转换成JSON对象。</p>
<p>JSON对象其实质是一个NSDAta对象。</p>
<h1 id="2-AnyObject转JSON"><a href="#2-AnyObject转JSON" class="headerlink" title="2 AnyObject转JSON"></a>2 AnyObject转JSON</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = [<span class="type">String</span>: <span class="type">String</span>]()</span><br><span class="line">dict[<span class="string">"name"</span>] = <span class="string">"阳君"</span></span><br><span class="line">dict[<span class="string">"qq"</span>] = <span class="string">"937447974"</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">NSJSONSerialization</span>.isValidJSONObject(dict) &#123; <span class="comment">// 能否转换为JSON Data</span></span><br><span class="line">        <span class="comment">// 转换为JSON Data</span></span><br><span class="line">        <span class="keyword">let</span> data  = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.dataWithJSONObject(dict, options: <span class="type">NSJSONWritingOptions</span>.<span class="type">PrettyPrinted</span>)</span><br><span class="line">        <span class="comment">// 转换为json串</span></span><br><span class="line">        <span class="keyword">self</span>.jsonString = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"json生成:\(self.jsonString)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"转换出错:\(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-JSON转AnyObject"><a href="#3-JSON转AnyObject" class="headerlink" title="3 JSON转AnyObject"></a>3 JSON转AnyObject</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json转data</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">self</span>.jsonString?.dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// data转JSON Object</span></span><br><span class="line">        <span class="keyword">let</span> jsonObject = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragments</span>)</span><br><span class="line">        <span class="comment">// JSON Object转实际对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dict = jsonObject <span class="keyword">as</span>? <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">AnyObject</span>&gt; &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"json解析:\(dict)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"解析xml出错:\(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160;</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/06/08/Article/谜一样的 Runloop(2_2) /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/08/Article/谜一样的 Runloop(2_2) /" itemprop="url">谜一样的 Runloop(2_2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-08T12:12:42+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="The-Run-Loop-Sequence-of-Events"><a href="#The-Run-Loop-Sequence-of-Events" class="headerlink" title="The Run Loop Sequence of Events"></a>The Run Loop Sequence of Events</h1><hr>
<p>下面我们看一下 runloop 从启动到退出的整个生命周期内做了哪些事情：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054440.jpg" alt></p>
<p>从上图可以看出，runloop 的生命周期大概要经历三个阶段：</p>
<ul>
<li>runloop 启动后首先处理待处理的事件，如：timer、input source；</li>
<li>进入休眠状态，等待新任务的到来；</li>
<li>有新任务了，runloop(准确地说是 thread) 被唤醒，处理新任务，runloop 重启或退出。</li>
</ul>
<p>需要注意的是：runloop 启动后如果有 port-based input sources event 需要处理，则 runloop 在处理完该事件后直接退出。</p>
<p>runloop 在整个生命周期内还有一件重要的事情就是与 observer 的交互。我们可以通过设置 runloop 的 observer 来监控 runloop 的内部状态。</p>
<h1 id="Understanding-Runloop-Internals-by-Runloop-Observer"><a href="#Understanding-Runloop-Internals-by-Runloop-Observer" class="headerlink" title="Understanding Runloop Internals by Runloop-Observer"></a>Understanding Runloop Internals by Runloop-Observer</h1><hr>
<p>runloop 之所以像谜一样让人琢磨不透，主要在于我们难于了解其内部实现机制、触发时机，同时也很难感受到它的存在。虽然，<a href="http://zxfcumtcs.github.io/2014/11/15/runloop/" target="_blank" rel="noopener">前文</a>通过 pseudo-code 的形式模拟了 runloop 的内部实现，但对于 runloop 真正何时会被触发，何时结束还是不太清楚。</p>
<p>幸运的是，Apple 还是给了我们近距离观察 runloop 的机会——runloop observer(可以形象地将其称之为 runloop 之窗 ^_^)。</p>
<p>通过 runloop observer 我们可以近距离的监听 runloop 以下重要事件：</p>
<ul>
<li>runloop 启动——kCFRunLoopEntry；</li>
<li>runloop 即将处理 timer——kCFRunLoopBeforeTimers；</li>
<li>runloop 即将处理 input source event——kCFRunLoopBeforeSources；</li>
<li>runloop 即将进入休眠状态——kCFRunLoopBeforeWaiting；</li>
<li>runloop 被唤醒，但还未处理唤醒它的事件——kCFRunLoopAfterWaiting；</li>
<li>runloop 退出——kCFRunLoopExit。</li>
</ul>
<h2 id="CFRunLoopObserver-——-runloop-之窗。"><a href="#CFRunLoopObserver-——-runloop-之窗。" class="headerlink" title="CFRunLoopObserver —— runloop 之窗。"></a>CFRunLoopObserver —— runloop 之窗。</h2><p>Apple 君为我们提供了两个创建<code>CFRunLoopObserver</code>的接口：</p>
<p><code>CFRunLoopObserverCreate</code>以及<code>CFRunLoopObserverCreateWithHandler</code>。</p>
<p>两者的区别仅在于前者以函数指针的形式提供监听回调，后者以 block 的形式提供回调接口。</p>
<p>以<code>CFRunLoopObserverCreateWithHandler</code>为例，Observer 的实现大致如下：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054507.jpg" alt></p>
<p>我们可以选择要监听的 runloop 事件，上面代码中使用了<code>kCFRunLoopAllActivities</code>，其他还有：<code>kCFRunLoopEntry</code>、<code>kCFRunLoopBeforeTimers</code>、<code>kCFRunLoopBeforeSources</code>、<code>kCFRunLoopBeforeWaiting</code>、<code>kCFRunLoopAfterWaiting</code>以及<code>kCFRunLoopExit</code>。</p>
<h2 id="Runloop-Observer-of-Main-Runloop"><a href="#Runloop-Observer-of-Main-Runloop" class="headerlink" title="Runloop Observer of Main Runloop"></a>Runloop Observer of Main Runloop</h2><p>首先，我们通过 runloop observer 监听一下 main runloop。<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054520.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054530.png" alt></p>
<p>从上面的 log 我们可以得出：<strong>main runloop 在主界面初始化完成，即将显示到屏幕前自动启动，runloop 启动后 (唤醒后) 会依次处理 timer(如果有)、source event(如果有)并在此前通知 observer。</strong></p>
<p>为了 log 显示简洁突出主题，下面我们只监听<code>kCFRunLoopEntry</code>、<code>kCFRunLoopBeforeWaiting</code>、<code>kCFRunLoopAfterWaiting</code>以及<code>kCFRunLoopExit</code>事件。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054545.jpg" alt></p>
<p><strong>main runloop 每分钟会被唤醒一次！(不明所以)</strong></p>
<p>在界面添加按钮，在其点击 handler 中 reload tableview：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054559.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054613.png" alt></p>
<p><strong>UI 事件唤醒 main runloop 直到处理完该事件，main runloop 再次进入休眠。</strong></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054632.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054639.png" alt>]</p>
<p><strong>如果唤醒 runloop 的事件含有异步操作，runloop 不会等待异步操作完成。<code>viewWillAppear:</code>和<code>viewDidAppear:</code>不在同一次 runloop 中被调用。</strong></p>
<h2 id="Runloop-Observer-of-Other-Runloop"><a href="#Runloop-Observer-of-Other-Runloop" class="headerlink" title="Runloop Observer of Other Runloop"></a>Runloop Observer of Other Runloop</h2><p>main runloop 作为整个 app 的神经中枢，很大程度上受系统所控制，下面我们通过 runloop observer 观察一下子线程的 runloop。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054707.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054712.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054728.png" alt></p>
<p><strong>timer 会唤醒 runloop 但不会使 runloop 退出</strong></p>
<p>如果子线程的 runloop 不添加任何 timer、source event：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054748.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054803.png" alt></p>
<p><strong>可以看到，此情况下，runloop 直接退出，连 runloop observer 都不通知一下 (runloop 根本没有启动)！</strong></p>
<p>下面再看一个更加复杂点的情况，添加第二个按钮，在其点击事件中向子线程发送 performSelector 消息：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054904.png" alt></p>
<p>子线程的 timer handler、performSelector handler 如下：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054914.png" alt></p>
<p>在子线程启动并触发 timer，但 timer handler 未返回之前，点击第二个 button：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054941.png" alt></p>
<p>可以看到，子线程在 timer handler 返回后才处理 performSelector 消息，并且在一次 runloop 中可以处理多个事件。</p>
<p>奇怪的是，runloop 在处理完 performSelector 消息后，还处理了另一个 timer fire 事件，随后退出。</p>
<p>ok，小结一下：</p>
<ul>
<li>main runloop 在主界面即将显示前由系统启动 (主界面 controller 的 <code>viewWillAppear:</code>执行后启动)；</li>
<li>runloop 启动后 (唤醒后) 会依次处理 timer(如果有)、source event(如果有)并在此前通知 observer；</li>
<li>main runloop 每分钟会被唤醒一次！(不明所以)；</li>
<li>UI 事件唤醒 main runloop 直到处理完该事件，如果该事件含有异步操作，runloop 不会等待异步操作完成；</li>
<li>UIViewController 的<code>viewWillAppear:</code>和<code>viewDidAppear:</code>不在同一次 runloop 中被调用；</li>
<li>timer 会唤醒 runloop 但不会使 runloop 退出；</li>
<li>如果子线程的 runloop 没有绑定 timer 或 source event，其 runloop 不会启动；</li>
<li>一次 runloop 可以处理多个事件。</li>
</ul>
<h1 id="Autorelease-and-Runloop"><a href="#Autorelease-and-Runloop" class="headerlink" title="Autorelease and Runloop"></a>Autorelease and Runloop</h1><hr>
<p>在 MRC 中，autorelase 作为重要的内存管理机制而被广大程序猿们烂记于心。我们都知道，autorelease 对象会被放入 autorelease pool，最终会被自动 release！借用一句广告词：<strong>有了 autorelease，程序猿们再也不用担心内存泄漏了！</strong></p>
<p>那么，问题来了：autorelease pool 中的对象到底什么时候会被真正的 release？</p>
<p>嗯，这也是一道很好的面试题！</p>
<p>答案也很简单，每次 runloop 退出前都会处理 autorelease pool——将其中的所有 object 都 release 一次。</p>
<p>咱们还是通过代码来看看吧，将前面提到的子线程的 performSelector 实现改成如下所示：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-055000.png" alt></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-055013.png" alt></p>
<p>是的，如预期所料，<code>testAutoreleaseObj</code>作为 autorelease object 在 runloop 退出前被 release 了。</p>
<p>autorelease 固然好用，但在使用过程中也需谨慎，否则容易出问题，并且由 autorelease 引发的问题一般较难排查。<br>常见问题有：</p>
<ul>
<li>autorelease object 被手动 release；</li>
<li>跨 runloop 使用 autorelease object。</li>
</ul>
<p>一旦在大型项目中出现第一个问题，很难排查，其 crash 堆栈如下：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-055025.png" alt></p>
<p>从这个堆栈中我们能得到的只有：autorelease object 提前被手动 release！<br>呵呵，至于是哪个 object 被提前 release 了，不得而知！</p>
<p>第二个问题主要出现在类的对象含有 autorelease 的成员变量：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-055044.png" alt></p>
<p><code>testViewController</code>类的实例保存了 autorelease 的<code>_str</code>，由于<code>viewDidAppear:</code>的调用在另一 runloop 中，此时<code>_str</code>已经释放！</p>
<p>是的，在类的成员变量中保存 autorelease 对象是一件十分危险的事情！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<p>runloop 作为事件处理的神经中枢，对整个 app 的意义不言而喻。准确而深入地了解 runloop 的机制，对程序猿的意义也不言而喻！</p>
<p>这两篇文章，我们简要介绍了 runloop 的基本概念、通过 pseudo-code 遐想了 runloop 的实现机制、通过 runloop observer 偷窥了 runloop 的重要时刻。</p>
<p>当然，runloop 还有很多问题值得探索…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/06/07/Article/谜一样的 Runloop(1_2) /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/07/Article/谜一样的 Runloop(1_2) /" itemprop="url">谜一样的 Runloop(1_2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-07T12:12:42+08:00">
                2017-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr>
<p>刚开始接触 iOS 时，block 和 runloop 让我望而生畏。block 那神奇的语法以及与外部变量纠缠不清的关系，还有 retain cycle 这个恶魔，短时间确实难以接受！runloop 更是谜一样的虚无飘渺，又似乎若隐若现，仿佛能感受到它的存在，但始终又不得其真面目！</p>
<p>Apple 官方给 run loop 的定义：run loop 是线程的基础支撑，是循环处理事件的机制，一个具体的 run loop 就是一个事件处理循环。</p>
<p>run loop 的目的是使线程在没有事情可做时进入休眠状态，避免 CPU 空转。</p>
<blockquote>
<p>Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p>
</blockquote>
<h1 id="Runloop-Modes"><a href="#Runloop-Modes" class="headerlink" title="Runloop Modes"></a>Runloop Modes</h1><hr>
<p>简单地说，runloop mode 是事件源的集合 + runloop 观察者的集合。runloop 每次都运行在某个特定的 mode 上。</p>
<p>之所以要引入 mode 的概念，是希望 runloop 在监听过程中过滤掉不关心的事件源，只专注于某些特定的事件。</p>
<p>Cocoa and Core Foundation 已经为我们预定义了若干 mode，而我们也可以自定义 mode。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-053955.jpg" alt></p>
<p>如果某个 input source 所属的 mode 不是当前监听的 mode，那其产生的所有事件都将被 hold 住，直到 runloop 运行在与其匹配的 mode 上。</p>
<p>注意：当有 UI 滑动事件时，系统会将 main runloop 切换到<code>NSEventTrackingRunLoopMode</code>，以限定此时的事件源，确保滑动的流畅性。</p>
<p>同时，在默认情况下<code>NSRunLoopCommonModes</code>包含<code>NSEventTrackingRunLoopMode</code>，也就是说与<code>NSRunLoopCommonModes</code>关联的事件源也与<code>NSEventTrackingRunLoopMode</code>关联。</p>
<p>而此时，如果有子线程想通过<code>performSelecorOnMainThread...</code>或<code>dispatch_async(dispatch_get_main_queue(),^{})</code>在主线程上执行某 <code>selector</code>，默认情况下上述两种方式产生的事件是关联到<code>NSRunLoopCommonModes</code>，因此在 UI 滑动时也会响应该事件并执行指定的 <code>selector</code>，从而影响滑动的流畅性。</p>
<p>为了避免此问题，可以封装上述接口，使其指定的 <code>selector</code> 运行在 main runloop 的其他 mode 上，如：<code>NSDefaultRunLoopMode</code>。</p>
<h1 id="Runloop-and-Thread"><a href="#Runloop-and-Thread" class="headerlink" title="Runloop and Thread"></a>Runloop and Thread</h1><hr>
<p>如果要问 runloop 与 thread 是什么关系？</p>
<p>答：runloop 是 thread 不断跳动的心脏！</p>
<p>每个 thread 都有自己的 runloop，可以通过<code>NSRunLoop</code>的类方法<code>currentRunLoop</code>获取当前线程的 runloop。但只有 main thread 的 runloop 默认是开启的，其他线程如果希望持续存活下去，就需要手动开启 runloop。</p>
<p>当线程没有开启 runloop 时，其生命周期将随其 <code>main</code> 函数的结束而终结；当开启 runloop 时，线程会进入休眠状态，直到相应的事件到来。形象地说前者生命周期是条直线，后者是个圆。</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054028.png" alt></p>
<p>那么什么情况下需要开启线程的 runloop 呢？(当然，这里讨论的对象是子线程)</p>
<p>基本原则是：<strong>线程需要处理异步事件。</strong></p>
<p>如果线程只是用来处理同步任务，没必要开启 runloop，也就是说 runloop 一定是与异步事件相关的！</p>
<p>具体来讲大概以下几种情况需要开启 runloop：</p>
<ul>
<li>需要通过端口或自定义输入源与其他线程通讯；</li>
<li>在线程中需要使用定时器；</li>
<li>在线程上使用<code>performSelector</code>系列方法；</li>
<li>需要线程周期性地执行一些任务。</li>
</ul>
<p>至于如何开启子线程的 runloop 就不过多的讲了，可以参考一下 Apple 的官方文档:<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">Threading Programming Guide</a></p>
<p>需要注意的是，在开启 runloop 前，至少要绑定一个事件源到 runloop 上，否则 runloop 将直接退出。</p>
<p>事件源大概有四类：</p>
<ul>
<li>Port-Based Sources</li>
<li>Custom Input Sources</li>
<li>Cocoa Perform Selector Sources</li>
<li>Timer Sources</li>
</ul>
<p>严格来讲，前三种事件源自来线程外部，Apple 将其称之为 input sources，timer 是来自线程内部的，与前三者有所区别。</p>
<p>对于上述事件源有几个要注意的点：</p>
<ul>
<li>在子线程上执行 performSelector 时，子线程需要开启 runloop，不然 selector 将会入队，直到 runloop 启动才会被执行；</li>
<li>所有入队的 perform selector 将会在一次 runloop 中全部被处理，而不是每次 runloop 处理一个 selector；</li>
<li>当 selector 执行后，该 perform source 会被从 runloop 上移除掉；</li>
<li>因 timer 触发的事件不会使 runloop 退出，(port-based input source even 会使 runloop 退出)；</li>
<li>当 timer 触发时 runloop 正在处理其他事件，timer handler 需要等到下一个 loop 才会被执行；</li>
<li>如果 runloop 没有启动，timer 永远不会触发。</li>
</ul>
<p>线程、runloop 以及 event source 之间的关系 (<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">来自</a>)：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054043.png" alt></p>
<h1 id="NSRunLoop-Internals"><a href="#NSRunLoop-Internals" class="headerlink" title="NSRunLoop Internals"></a>NSRunLoop Internals</h1><hr>
<p><code>NSRunLoop</code>向外提供了多个接口可以启动 runloop，详细描述如下表所示：<br><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-23-054122.png" alt></p>
<p>可以看到，<code>run</code>以及<code>runUntilDate:</code>内部都是通过调用<code>runMode:beforeDate:</code>函数实现的。</p>
<p><em>对于熟悉服务器网络编程的同学来说，后台服务器其实就是一个大 runloop，其主要通过 <code>select</code>、<code>pool</code> 或 <code>epool</code> 等方式实现这个 runloop。以<code>select</code>为例，系统内核不断轮询该<code>select</code>关注的 fd，当有网络事件需要处理时，唤醒服务器进程处理事件，否则不断轮询。</em></p>
<p><a href="https://mikeash.com/pyblog/friday-qa-2010-01-01-nsrunloop-internals.html" target="_blank" rel="noopener">Mike Ash</a> 大神通过<code>select</code>，以 pseudo-code 的方式描述了<code>runMode:beforeDate:</code>的实现，同时也形象地说明了 runloop 的实质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate</span><br><span class="line">&#123;</span><br><span class="line">   if(![self hasSourcesOrTimersForMode:mode])</span><br><span class="line">      return NO;</span><br><span class="line">        </span><br><span class="line">   // with timer support, this code has to loop until an input source fires</span><br><span class="line">   BOOL didFireInputSource = NO;</span><br><span class="line">   while(!didFireInputSource)</span><br><span class="line">   &#123;</span><br><span class="line">       fd_set fdset;</span><br><span class="line">       FD_ZERO(&amp;fdset);</span><br><span class="line">       </span><br><span class="line">       for(inputSource in [_inputSources objectForKey: mode])</span><br><span class="line">           FD_SET([inputSource fileDescriptor], &amp;fdset);</span><br><span class="line">       </span><br><span class="line">       // the timeout needs to be set from the limitDateand from the list of timers</span><br><span class="line">       // start with the limitDate</span><br><span class="line">       NSTimeInterval timeout = [limitDate timeIntervalSinceNow];</span><br><span class="line">       </span><br><span class="line">       // now run through the list of timers and set the</span><br><span class="line">       // timeout to the smallest one found in them and</span><br><span class="line">       // in the limitDate</span><br><span class="line">       for(timer in [_timerSources objectForKey: mode])</span><br><span class="line">           timeout = MIN(timeout, [[timer fireDate] timeIntervalSinceNow]);</span><br><span class="line">       </span><br><span class="line">       // now run select</span><br><span class="line">       select(fdset, timeout);</span><br><span class="line">       </span><br><span class="line">       // process input sources first (this choice is arbitrary)</span><br><span class="line">       for(inputSource in [[[_inputSources objectForKey: mode] copy] autorelease])</span><br><span class="line">           if(FD_ISSET([inputSource fileDescrptor], &amp;fdset))</span><br><span class="line">           &#123;</span><br><span class="line">               didFireInputSource = YES;</span><br><span class="line">               [inputSource fileDescriptorIsReady];</span><br><span class="line">           &#125;</span><br><span class="line">       </span><br><span class="line">       // now process timers</span><br><span class="line">       // responsibility for updating fireDate for repeating timers</span><br><span class="line">       // and for removing the timer from the runloop for non-repeating timers</span><br><span class="line">       // rests in the timer class, not in the runloop</span><br><span class="line">       for(timer in [[[_timerSources objectForKey: mode] copy] autorelease])</span><br><span class="line">           if([[timer fireDate] timeIntervalSinceNow] &lt;= 0)</span><br><span class="line">               [timer fire];</span><br><span class="line">       </span><br><span class="line">       // see if we timed out, if so, abort!</span><br><span class="line">       // this is checked at the end to ensure that timers and inputs are</span><br><span class="line">       // always processed at least once before returning</span><br><span class="line">       if([limitDate timeIntervalSinceNow] &lt; 0)</span><br><span class="line">           break;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述<code>runMode:beforeDate:</code>的 pseudo-code 中：</p>
<ul>
<li>第 3 行，首先判断是否有 input source 或 timer 绑定到 runloop 的指定 mode 下；</li>
<li>第 13 行，用指定 mode 下的 inputsource 设置 fdset；</li>
<li>第 23~24 行，找出此次轮询的最小过期时间；</li>
<li>第 27 行，启动 runloop；</li>
<li>第 30 行，select 返回，表明有 inputsource 到达或 timer fire；</li>
<li>30 行以下代码用于处理到达的事件，需要注意的时：如果 select 是因为 inputsource 到达而返回的，第 33 行会将<code>didFireInputSource</code>设为 YES，从而导致<code>runMode:beforeDate:</code>退出，而 timer fire 时没有设该标志位，也就是所谓的 timer fire 不会导致 runloop 退出。</li>
</ul>
<p>是的，runloop 其实就这么简单。当然，由于没有 runloop 的源码，其内部真正如何实现不得而知。但总体思路应该大同小异！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/05/17/深入理解KVC与KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/17/深入理解KVC与KVO/" itemprop="url">深入理解KVC与KVO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-17T12:12:42+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-KVC"><a href="#1-KVC" class="headerlink" title="1 KVC"></a>1 KVC</h1><p>KVC（Key-value coding）键值编码。简单来说，是可以通过对象属性名称（Key）直接给属性值（value）赋值。</p>
<h2 id="1-1-使用"><a href="#1-1-使用" class="headerlink" title="1.1 使用"></a>1.1 使用</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> accessInstanceVariablesDirectly; <span class="comment">// 是否禁用KVC</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;                 <span class="comment">// getter</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key; <span class="comment">// setter</span></span><br></pre></td></tr></table></figure>
<p>通过 setter 方法我们就可以动态给 readonly 的对象赋值。key 可以是属性也可以是_属性。</p>
<h2 id="1-2-底层调用"><a href="#1-2-底层调用" class="headerlink" title="1.2 底层调用"></a>1.2 底层调用</h2><p>假如我们调用 <code>[[NSObject alloc] setValue:nil forKey:@&quot;property&quot;];</code>，其 KVC 调用如下所示：</p>
<ol>
<li>去模型中查找有没有对应的 setter 方法：例如：setProperty 方法，有就直接调用这个 setter 方法给属性赋值;</li>
<li>如果找不到 setter 方法，接着就会去寻找有没有 property Ivar，如果有，就直接进行 <code>void object_setIvar ( id obj, Ivar ivar, id value )</code> 赋值;</li>
<li>如果找不到 property 属性，接着又会去寻找 _property Ivar，如果有，直接进行 Ivar 赋值</li>
<li>如果都找不到会调用 <code>setValue: forUndefinedKey:</code>, 然后报出如下所示的崩溃信息。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/937447974/Blog/master/Resources/2017032101.png" alt></p>
<p>从崩溃信息我们可以发现如下信息</p>
<ol>
<li>KVC 使用了 OSSpinLock 锁</li>
<li>其存储信息可分散在 CFSetCreateMutable -&gt; CFHash -&gt; CFSetGetValue -&gt; CFSetAddValue</li>
</ol>
<h1 id="2-KVO"><a href="#2-KVO" class="headerlink" title="2 KVO"></a>2 KVO</h1><p>KVO (Key-Value Observing) 建立在 KVC 之上，它通过重写 KVC 和监听 setter 方法，向外发送通知。</p>
<h2 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用"></a>2.1 使用</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 注册观察者，实施监听</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在回调方法中处理属性发生的变化</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == &lt;<span class="meta">#context#&gt;) &#123;</span></span><br><span class="line">        &lt;<span class="meta">#code to be executed upon observing keypath#&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 移除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当父类和子类同时 KVO 同一个对象时，在 <code>dealloc</code> 移除引起崩溃时 应对 context 赋值，移除时也应通过<code>(void)removeObserver: forKeyPath: context:</code> 方法移除。</p>
</blockquote>
<h2 id="2-2-底层实现"><a href="#2-2-底层实现" class="headerlink" title="2.2 底层实现"></a>2.2 底层实现</h2><p><img src="https://raw.githubusercontent.com/937447974/Blog/master/Resources/2017032201.png" alt></p>
<p><img src="https://raw.githubusercontent.com/937447974/Blog/master/Resources/2017032202.png" alt></p>
<p>通过上面两张图的对比，我们发现对 test 执行 <code>addObserver</code> 操作时，test 的 isa 指向了NSKVONotifying_KVOTest。执行 <code>removeObserver</code> 操作时，其 isa 再次指回了 KVOTest。这也就是 isa-swizzling 技术，isa-swizzling 就是类型混合指针机制。</p>
<p>由此我们可以结合 runtime 得出如下结论。</p>
<ol>
<li>KVO 的底层是 runtime 编译时动态生成 NSKVONotifying_Class 对象，然后通过 object_setClass(id obj, Class cls) 动态修改当前类的 isa 指向 NSKVONotifying_Class。</li>
<li>NSKVONotifying_Class 是一个动态类，其内部继承了 NSKVONotifying 对象。</li>
<li>NSKVONotifying 内实现了如下操作：<ol>
<li>重写了 KVC 的机制，这样调用 <code>setValue: forKey:</code> 时，外部 Observer 也能接到通知。</li>
<li>绑定了原 isa 便于 <code>removeObserver</code> 时，修改原始对象的 isa; </li>
<li>通过动态方法决议与消息转发实现了属性的 setter 方法。</li>
<li>可以通过 NSObject 内的 NSKeyValueObserverNotification 扩展方法向外发送 NSKeyValueObservingOptions 通知。如下所示</li>
</ol>
</li>
</ol>
<pre><code class="objc">[test willChangeValueForKey:<span class="string">@"str"</span>]; <span class="comment">// KVO 存储旧值</span>
test -&gt; _str = <span class="string">@"阳君"</span>;               <span class="comment">// 指针改变值</span>
[test didChangeValueForKey:<span class="string">@"str"</span>];  <span class="comment">// KVO 存储新值，且发出通知</span>
</code></pre>
<blockquote>
<p><code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 成对出现缺一不可。</p>
</blockquote>
<p>&#160;</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caicoder.github.io/2017/04/16/动态方法决议与消息转发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="caicoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caicoder的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/动态方法决议与消息转发/" itemprop="url">动态方法决议与消息转发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-16T12:12:42+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Objective-C中，如果向一个对象发送一条该对象无法处理的消息(对应selector不存在)，会导致程序crash， 但是，在crash之前，oc的运行时系统会先经过以下两个步骤：</p>
<ol>
<li>Dynamic Method Resolution</li>
<li>Message Forwarding</li>
</ol>
<h2 id="1-Dynamic-Method-Resolution（动态方法决议）"><a href="#1-Dynamic-Method-Resolution（动态方法决议）" class="headerlink" title="1 Dynamic Method Resolution（动态方法决议）"></a>1 Dynamic Method Resolution（动态方法决议）</h2><p>Objective C 提供了一种名为动态方法决议的手段，使得我们可以在运行时动态地为一个 selector 提供实现。我们只要实现 +resolveInstanceMethod: 或 +resolveClassMethod: 方法，并在其中为指定的 selector  提供实现即可（通过调用运行时函数 class_addMethod 来添加)，并返回YES，运行时系统会重启一次消息的发送过程，调用动态添加的方法。例如,下面的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>class_addMethod 方法动态的添加新的方法与对应的实现，如果调用了[MyClass resolveThisMethodDynamically],将会转到动态添加的dynamicMethodIMP 方法中。Objective-C的方法本质上是一个至少包含两个参数(id self, SEL _cmd)的C函数，这样，当重启消息发送时，就能在类中找到@selector(dynamicMethodIMP)了。而如果方法返回NO时，将会进入下一步：消息转发(Message Forwarding)</p>
<h2 id="2-Message-Forwarding（消息转发）"><a href="#2-Message-Forwarding（消息转发）" class="headerlink" title="2 Message Forwarding（消息转发）"></a>2 Message Forwarding（消息转发）</h2><p>消息转发分为两步：</p>
<p>首先运行时系统会调用- (id)forwardingTargetForSelector:(SEL)aSelector方法，如果这个方法中返回的不是nil或者self，运行时系统将把消息发送给返回的那个对象。</p>
<p>如果返回的是nil或者self，运行时系统首先会调用- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector方法来获得方法签名，方法签名记录了方法的参数和返回值的信息。</p>
<p>如果－methodSignatureForSelector 返回的是nil, 运行时系统会抛出unrecognized selector exception，程序到这里就结束了。</p>
<h2 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3 流程图"></a>3 流程图</h2><p>整个流程可以用下面这张图表示</p>
<p><img src="https://raw.githubusercontent.com/937447974/Blog/master/Resources/2016101401.png" alt></p>
<p>调用<code>[[YJItem alloc] test]</code>，从控制台打印方法的执行顺序如下所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolveInstanceMethod:</span><br><span class="line">forwardingTargetForSelector:</span><br><span class="line">methodSignatureForSelector:</span><br><span class="line">resolveInstanceMethod:</span><br><span class="line">doesNotRecognizeSelector:</span><br><span class="line">-[YJItem test]: unrecognized selector sent to instance <span class="number">0x61800000d5c0</span></span><br></pre></td></tr></table></figure>
<p>&#160;</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">caicoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">caicoder</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
